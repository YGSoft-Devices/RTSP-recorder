#!/usr/bin/env python3
"""
RTSP Recorder Web Management Interface
Flask backend for configuring rpi_av_rtsp_recorder.sh

Target: Raspberry Pi OS Trixie (64-bit) - Raspberry Pi 3B+/4/5

Version: 2.29.0
"""

import os
import re
import json
import subprocess
import time
import threading
from datetime import datetime
from pathlib import Path
from flask import Flask, render_template, request, jsonify, redirect, url_for, Response

app = Flask(__name__)

# ============================================================================
# Meeting API Heartbeat State (global)
# ============================================================================
meeting_state = {
    'last_heartbeat': None,       # Timestamp of last successful heartbeat
    'last_heartbeat_error': None, # Last error message if any
    'connected': False,           # Current connection status
    'thread_running': False,      # Whether heartbeat thread is active
}
meeting_lock = threading.Lock()
meeting_thread = None

# ============================================================================
# Camera Profiles Scheduler State (global)
# ============================================================================
camera_profiles_state = {
    'scheduler_running': False,   # Whether scheduler thread is active
    'active_profile': None,       # Currently active profile name
    'last_profile_change': None,  # Timestamp of last profile change
    'profiles': {}                # Loaded profiles data
}
camera_profiles_lock = threading.Lock()
camera_profiles_thread = None

# Scheduler state file (shared between Gunicorn workers)
SCHEDULER_STATE_FILE = '/tmp/rpi-cam-scheduler-state.json'


def load_scheduler_state():
    """Load scheduler state from shared file."""
    try:
        if os.path.exists(SCHEDULER_STATE_FILE):
            with open(SCHEDULER_STATE_FILE, 'r') as f:
                return json.load(f)
    except Exception as e:
        print(f"[Scheduler] Error loading state: {e}")
    return {'running': False, 'active_profile': None, 'last_change': None, 'pid': None}


def save_scheduler_state(running, active_profile=None, last_change=None):
    """Save scheduler state to shared file."""
    try:
        state = {
            'running': running,
            'active_profile': active_profile,
            'last_change': last_change,
            'pid': os.getpid() if running else None
        }
        with open(SCHEDULER_STATE_FILE, 'w') as f:
            json.dump(state, f)
    except Exception as e:
        print(f"[Scheduler] Error saving state: {e}")


# ============================================================================
# Platform Detection (Raspberry Pi specific)
# ============================================================================

def detect_platform():
    """Detect Raspberry Pi model and available features."""
    platform_info = {
        'is_raspberry_pi': True,
        'model': 'Raspberry Pi',
        'has_vcgencmd': False,
        'has_led_control': False,
        'has_libcamera': False,
        'boot_config': None
    }
    
    # Get Raspberry Pi model
    if os.path.exists('/proc/device-tree/model'):
        try:
            with open('/proc/device-tree/model', 'r') as f:
                model = f.read().strip().rstrip('\x00')
                platform_info['model'] = model
        except:
            pass
    
    # Check for vcgencmd (Raspberry Pi tools)
    platform_info['has_vcgencmd'] = os.path.exists('/usr/bin/vcgencmd')
    
    # Check for LED control (always available on Pi)
    platform_info['has_led_control'] = (
        os.path.exists('/sys/class/leds/PWR') or 
        os.path.exists('/sys/class/leds/ACT') or
        os.path.exists('/sys/class/leds/led0') or
        os.path.exists('/sys/class/leds/led1')
    )
    
    # Check for libcamera
    platform_info['has_libcamera'] = (
        os.path.exists('/usr/bin/libcamera-hello') or
        os.path.exists('/usr/bin/libcamera-vid')
    )
    
    # Find boot config file (Trixie uses /boot/firmware/)
    boot_config_paths = [
        '/boot/firmware/config.txt',  # Raspberry Pi OS Trixie/Bookworm
        '/boot/config.txt',           # Raspberry Pi OS legacy
    ]
    for path in boot_config_paths:
        if os.path.exists(path):
            platform_info['boot_config'] = path
            break
    
    return platform_info

# Initialize platform info at startup
PLATFORM = detect_platform()

# Configuration file paths
CONFIG_FILE = "/etc/rpi-cam/config.env"
SERVICE_NAME = "rpi-av-rtsp-recorder"
SCRIPT_PATH = "/usr/local/bin/rpi_av_rtsp_recorder.sh"
BOOT_CONFIG_FILE = PLATFORM['boot_config'] or "/boot/firmware/config.txt"
WPA_SUPPLICANT_FILE = "/etc/wpa_supplicant/wpa_supplicant.conf"
NETWORK_MANAGER_AVAILABLE = os.path.exists("/usr/bin/nmcli")

# Default configuration values matching the bash script
DEFAULT_CONFIG = {
    # RTSP Settings
    "RTSP_PORT": "8554",
    "RTSP_PATH": "stream",
    # RTSP Authentication (optional - both required for auth to be enabled)
    "RTSP_USER": "",
    "RTSP_PASSWORD": "",
    
    # Video Settings (optimized for Pi 3B+ with software encoding)
    "VIDEO_WIDTH": "640",
    "VIDEO_HEIGHT": "480",
    "VIDEO_FPS": "15",
    "VIDEO_DEVICE": "/dev/video0",
    "CSI_ENABLE": "auto",
    "USB_ENABLE": "auto",
    
    # Camera Settings
    "CAMERA_AUTOFOCUS": "yes",  # yes, no, or auto (don't change)
    "CAMERA_PROFILES_ENABLED": "no",  # Enable camera profiles scheduler
    "CAMERA_PROFILES_FILE": "/etc/rpi-cam/camera_profiles.json",  # Profiles storage
    
    # H264 Encoding Settings (for x264enc on Pi 3B+)
    "H264_BITRATE_KBPS": "1200",
    "H264_KEYINT": "30",
    
    # Recording (disabled - use external recording via ffmpeg)
    "RECORD_ENABLE": "no",
    "RECORD_DIR": "/var/cache/rpi-cam/recordings",
    "SEGMENT_SECONDS": "300",
    "MIN_FREE_DISK_MB": "1000",
    "MAX_DISK_MB": "0",  # 0 = no limit, otherwise max storage in MB
    
    # Audio Settings
    "AUDIO_ENABLE": "auto",
    "AUDIO_RATE": "48000",
    "AUDIO_CHANNELS": "1",
    "AUDIO_BITRATE_KBPS": "64",
    "AUDIO_DEVICE": "auto",
    
    # Advanced Settings
    "GST_DEBUG_LEVEL": "2",
    "LOG_DIR": "/var/log/rpi-cam",
    "LOW_LATENCY": "1",
    
    # Meeting API Integration
    "MEETING_ENABLED": "no",
    "MEETING_API_URL": "https://meeting.example.com/api",
    "MEETING_DEVICE_KEY": "",
    "MEETING_TOKEN_CODE": "",
    "MEETING_HEARTBEAT_INTERVAL": "60",
    "MEETING_PROVISIONED": "no",  # Set to "yes" after successful provisioning (locks config)
    
    # Network Settings
    "NETWORK_MODE": "dhcp",  # dhcp, static
    "NETWORK_STATIC_IP": "",
    "NETWORK_GATEWAY": "",
    "NETWORK_DNS": "8.8.8.8",
    "NETWORK_INTERFACE_PRIORITY": "eth0,wlan1,wlan0",  # Order of preference
}

# System configuration (not in config.env, managed separately)
SYSTEM_DEFAULTS = {
    # WiFi settings (primary network)
    "WIFI_SSID": "",
    "WIFI_PASSWORD": "",
    "WIFI_COUNTRY": "FR",
    # Fallback WiFi (secondary network)
    "WIFI_FALLBACK_SSID": "",
    "WIFI_FALLBACK_PASSWORD": "",
    # WiFi interface assignments
    "WIFI_PRIMARY_INTERFACE": "wlan0",  # Built-in WiFi
    "WIFI_SECONDARY_INTERFACE": "wlan1",  # USB dongle 5GHz
    # LED settings (Pi only)
    "LED_PWR_ENABLE": "1",
    "LED_ACT_ENABLE": "1",
    # GPU Memory (Pi only)
    "GPU_MEM": "128",
}

# Configuration metadata for UI
CONFIG_METADATA = {
    "RTSP_PORT": {
        "label": "Port RTSP",
        "type": "number",
        "min": 1,
        "max": 65535,
        "help": "Port d'écoute du serveur RTSP",
        "category": "rtsp"
    },
    "RTSP_PATH": {
        "label": "Chemin RTSP",
        "type": "text",
        "help": "Chemin du flux (ex: rtsp://IP:port/stream)",
        "category": "rtsp"
    },
    "RTSP_USER": {
        "label": "Utilisateur RTSP",
        "type": "text",
        "help": "Nom d'utilisateur pour l'authentification RTSP (optionnel)",
        "category": "rtsp"
    },
    "RTSP_PASSWORD": {
        "label": "Mot de passe RTSP",
        "type": "password",
        "help": "Mot de passe pour l'authentification RTSP (optionnel)",
        "category": "rtsp"
    },
    "VIDEO_WIDTH": {
        "label": "Largeur vidéo",
        "type": "number",
        "min": 320,
        "max": 4096,
        "help": "Largeur en pixels",
        "category": "video"
    },
    "VIDEO_HEIGHT": {
        "label": "Hauteur vidéo",
        "type": "number",
        "min": 240,
        "max": 2160,
        "help": "Hauteur en pixels",
        "category": "video"
    },
    "VIDEO_FPS": {
        "label": "Images par seconde",
        "type": "number",
        "min": 1,
        "max": 60,
        "help": "Nombre d'images par seconde",
        "category": "video"
    },
    "VIDEO_DEVICE": {
        "label": "Périphérique vidéo",
        "type": "text",
        "help": "Chemin du périphérique USB (ex: /dev/video0)",
        "category": "video"
    },
    "CSI_ENABLE": {
        "label": "Caméra CSI",
        "type": "select",
        "options": ["auto", "yes", "no"],
        "help": "Activer la caméra CSI (Raspberry Pi Camera)",
        "category": "video"
    },
    "USB_ENABLE": {
        "label": "Caméra USB",
        "type": "select",
        "options": ["auto", "yes", "no"],
        "help": "Activer la caméra USB",
        "category": "video"
    },
    "CAMERA_AUTOFOCUS": {
        "label": "Autofocus",
        "type": "select",
        "options": ["yes", "no", "auto"],
        "help": "Activer l'autofocus au démarrage (auto = ne pas modifier)",
        "category": "video"
    },
    "CAMERA_PROFILES_ENABLED": {
        "label": "Scheduler profils caméra",
        "type": "select",
        "options": ["yes", "no"],
        "help": "Activer le changement automatique de profil selon l'heure",
        "category": "video"
    },
    "CAMERA_PROFILES_FILE": {
        "label": "Fichier des profils",
        "type": "text",
        "help": "Chemin du fichier JSON des profils caméra",
        "category": "video"
    },
    "RECORD_DIR": {
        "label": "Répertoire d'enregistrement",
        "type": "text",
        "help": "Chemin où stocker les enregistrements",
        "category": "recording"
    },
    "SEGMENT_SECONDS": {
        "label": "Durée des segments",
        "type": "number",
        "min": 30,
        "max": 3600,
        "help": "Durée de chaque fichier en secondes",
        "category": "recording"
    },
    "MIN_FREE_DISK_MB": {
        "label": "Espace libre minimum (Mo)",
        "type": "number",
        "min": 0,
        "max": 1000000,
        "help": "Espace disque libre à conserver en permanence. 0 = pas de limite. Les anciens enregistrements sont supprimés automatiquement.",
        "category": "recording"
    },
    "AUDIO_ENABLE": {
        "label": "Audio",
        "type": "select",
        "options": ["auto", "yes", "no"],
        "help": "Activer la capture audio",
        "category": "audio"
    },
    "AUDIO_RATE": {
        "label": "Fréquence d'échantillonnage",
        "type": "select",
        "options": ["22050", "44100", "48000"],
        "help": "Fréquence audio en Hz",
        "category": "audio"
    },
    "AUDIO_CHANNELS": {
        "label": "Canaux audio",
        "type": "select",
        "options": ["1", "2"],
        "help": "1 = Mono, 2 = Stéréo",
        "category": "audio"
    },
    "AUDIO_BITRATE_KBPS": {
        "label": "Débit audio (kbps)",
        "type": "number",
        "min": 32,
        "max": 320,
        "help": "Débit audio AAC en kbps",
        "category": "audio"
    },
    "AUDIO_DEVICE": {
        "label": "Périphérique audio",
        "type": "text",
        "help": "auto ou périphérique ALSA (ex: plughw:1,0)",
        "category": "audio"
    },
    "GST_DEBUG_LEVEL": {
        "label": "Niveau de debug GStreamer",
        "type": "select",
        "options": ["0", "1", "2", "3", "4", "5", "6"],
        "help": "0=aucun, 2=warnings, 3=info, 6=tout",
        "category": "advanced"
    },
    "LOG_DIR": {
        "label": "Répertoire des logs",
        "type": "text",
        "help": "Chemin pour stocker les fichiers de log",
        "category": "advanced"
    },
    "LOW_LATENCY": {
        "label": "Mode faible latence",
        "type": "select",
        "options": ["1", "0"],
        "help": "1 = activé, 0 = désactivé",
        "category": "advanced"
    },
    "H264_BITRATE_KBPS": {
        "label": "Débit H264 (kbps)",
        "type": "number",
        "min": 500,
        "max": 5000,
        "help": "Débit vidéo H264 (défaut: 1200 kbps pour Pi 3B+)",
        "category": "video"
    },
    "H264_KEYINT": {
        "label": "Intervalle keyframes",
        "type": "number",
        "min": 10,
        "max": 120,
        "help": "Intervalle entre images clés (défaut: 30)",
        "category": "video"
    },
    "RECORD_ENABLE": {
        "label": "Enregistrement local",
        "type": "select",
        "options": ["yes", "no"],
        "help": "Note: Désactivé via RTSP, utilisez ffmpeg externe",
        "category": "recording"
    },
    # Meeting API Configuration
    "MEETING_ENABLED": {
        "label": "Activer Meeting",
        "type": "select",
        "options": ["yes", "no"],
        "help": "Active l'intégration avec l'API Meeting",
        "category": "meeting"
    },
    "MEETING_API_URL": {
        "label": "URL de l'API Meeting",
        "type": "text",
        "help": "URL de base de l'API Meeting (ex: https://meeting.example.com/api)",
        "category": "meeting"
    },
    "MEETING_DEVICE_KEY": {
        "label": "Device Key",
        "type": "text",
        "help": "Clé unique du device fournie par Meeting",
        "category": "meeting"
    },
    "MEETING_TOKEN_CODE": {
        "label": "Token Code",
        "type": "password",
        "help": "Code d'authentification du device",
        "category": "meeting"
    },
    "MEETING_HEARTBEAT_INTERVAL": {
        "label": "Intervalle Heartbeat",
        "type": "number",
        "min": 10,
        "max": 300,
        "help": "Fréquence d'envoi du heartbeat en secondes",
        "category": "meeting"
    },
    "MEETING_PROVISIONED": {
        "label": "Provisionné",
        "type": "select",
        "options": ["yes", "no"],
        "help": "Indique si le device a été provisionné (verrouille la config Meeting)",
        "category": "meeting"
    },
    # Network Configuration
    "NETWORK_MODE": {
        "label": "Mode IP",
        "type": "select",
        "options": ["dhcp", "static"],
        "help": "DHCP automatique ou IP statique",
        "category": "network"
    },
    "NETWORK_STATIC_IP": {
        "label": "Adresse IP statique",
        "type": "text",
        "help": "Ex: 192.168.1.100/24",
        "category": "network"
    },
    "NETWORK_GATEWAY": {
        "label": "Passerelle",
        "type": "text",
        "help": "Ex: 192.168.1.1",
        "category": "network"
    },
    "NETWORK_DNS": {
        "label": "Serveur DNS",
        "type": "text",
        "help": "Ex: 8.8.8.8",
        "category": "network"
    },
    "NETWORK_INTERFACE_PRIORITY": {
        "label": "Priorité des interfaces",
        "type": "text",
        "help": "Ordre de priorité (ex: eth0,wlan1,wlan0)",
        "category": "network"
    },
}


# ============================================================================
# WiFi Management Functions
# ============================================================================

def get_wifi_networks():
    """Get list of available WiFi networks."""
    networks = []
    try:
        if NETWORK_MANAGER_AVAILABLE:
            # Force a rescan first
            subprocess.run(
                ['nmcli', 'dev', 'wifi', 'rescan'],
                capture_output=True, timeout=15
            )
            # Use NetworkManager
            result = subprocess.run(
                ['nmcli', '-t', '-f', 'SSID,SIGNAL,SECURITY', 'dev', 'wifi', 'list'],
                capture_output=True, text=True, timeout=30
            )
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split(':')
                    if len(parts) >= 3 and parts[0]:
                        # Avoid duplicates
                        if parts[0] not in [n['ssid'] for n in networks]:
                            networks.append({
                                'ssid': parts[0],
                                'signal': parts[1],
                                'security': parts[2] if parts[2] else 'Open'
                            })
        else:
            # Fallback to iwlist
            result = subprocess.run(
                ['sudo', 'iwlist', 'wlan0', 'scan'],
                capture_output=True, text=True, timeout=30
            )
            ssid_pattern = re.compile(r'ESSID:"([^"]*)"')
            for match in ssid_pattern.finditer(result.stdout):
                ssid = match.group(1)
                if ssid and ssid not in [n['ssid'] for n in networks]:
                    networks.append({'ssid': ssid, 'signal': 'N/A', 'security': 'N/A'})
    except Exception as e:
        print(f"Error scanning WiFi: {e}")
    return networks


def get_current_wifi():
    """Get current WiFi connection info."""
    info = {'connected': False, 'ssid': '', 'ip': ''}
    try:
        if NETWORK_MANAGER_AVAILABLE:
            result = subprocess.run(
                ['nmcli', '-t', '-f', 'NAME,TYPE,DEVICE', 'con', 'show', '--active'],
                capture_output=True, text=True, timeout=10
            )
            for line in result.stdout.strip().split('\n'):
                parts = line.split(':')
                if len(parts) >= 3 and parts[1] == '802-11-wireless':
                    info['connected'] = True
                    info['ssid'] = parts[0]
                    break
        else:
            result = subprocess.run(
                ['iwgetid', '-r'], capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                info['connected'] = True
                info['ssid'] = result.stdout.strip()
        
        # Get IP address
        result = subprocess.run(
            ['hostname', '-I'], capture_output=True, text=True, timeout=5
        )
        info['ip'] = result.stdout.strip().split()[0] if result.stdout.strip() else ''
    except Exception as e:
        print(f"Error getting WiFi info: {e}")
    return info


def connect_wifi(ssid, password, priority=0):
    """Connect to a WiFi network using the first available WiFi interface by priority."""
    try:
        if NETWORK_MANAGER_AVAILABLE:
            # Find first WiFi interface based on priority order
            wifi_interface = None
            interfaces = get_network_interfaces()
            priority_order = get_interface_priority()
            
            # Sort interfaces by priority
            for iface_name in priority_order:
                for iface in interfaces:
                    if iface['name'] == iface_name and iface['type'] == 'wifi':
                        wifi_interface = iface_name
                        break
                if wifi_interface:
                    break
            
            # Fallback to first wifi interface found
            if not wifi_interface:
                for iface in interfaces:
                    if iface['type'] == 'wifi':
                        wifi_interface = iface['name']
                        break
            
            if not wifi_interface:
                return False, "No WiFi interface found"
            
            # First check if connection already exists
            result = subprocess.run(
                ['nmcli', 'con', 'show', ssid],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                # Modify existing connection with security settings
                modify_cmd = ['sudo', 'nmcli', 'con', 'modify', ssid]
                if password:
                    modify_cmd.extend([
                        'wifi-sec.key-mgmt', 'wpa-psk',
                        'wifi-sec.psk', password
                    ])
                subprocess.run(modify_cmd, capture_output=True, timeout=30)
                # Activate connection
                result = subprocess.run(
                    ['sudo', 'nmcli', 'con', 'up', ssid],
                    capture_output=True, text=True, timeout=60
                )
                if result.returncode != 0:
                    return False, result.stderr or "Failed to activate connection"
            else:
                # Create new connection with nmcli con add (more reliable than dev wifi connect)
                con_name = ssid
                cmd = [
                    'sudo', 'nmcli', 'con', 'add',
                    'type', 'wifi',
                    'con-name', con_name,
                    'ifname', wifi_interface,
                    'ssid', ssid,
                    'connection.autoconnect', 'yes'
                ]
                
                # Add security settings if password provided
                if password:
                    cmd.extend([
                        'wifi-sec.key-mgmt', 'wpa-psk',
                        'wifi-sec.psk', password
                    ])
                
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                if result.returncode != 0:
                    return False, result.stderr or "Failed to create connection"
                
                # Activate the connection
                result = subprocess.run(
                    ['sudo', 'nmcli', 'con', 'up', con_name],
                    capture_output=True, text=True, timeout=60
                )
                if result.returncode != 0:
                    return False, result.stderr or "Failed to connect"
            
            # Set priority if specified
            if priority > 0:
                subprocess.run(
                    ['sudo', 'nmcli', 'con', 'modify', ssid,
                     'connection.autoconnect-priority', str(priority)],
                    capture_output=True, timeout=10
                )
            return True, f"Connected to {ssid} via {wifi_interface}"
        else:
            # Use wpa_supplicant directly
            return configure_wpa_supplicant(ssid, password, priority)
    except Exception as e:
        return False, str(e)


def configure_wpa_supplicant(ssid, password, priority=0):
    """Configure WiFi via wpa_supplicant.conf."""
    try:
        # Read existing config
        config_content = ""
        if os.path.exists(WPA_SUPPLICANT_FILE):
            with open(WPA_SUPPLICANT_FILE, 'r') as f:
                config_content = f.read()
        
        # Ensure header exists
        if 'ctrl_interface=' not in config_content:
            config_content = """ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=FR

""" + config_content
        
        # Remove existing network block for this SSID
        pattern = rf'network=\{{[^}}]*ssid="{re.escape(ssid)}"[^}}]*\}}'
        config_content = re.sub(pattern, '', config_content, flags=re.DOTALL)
        
        # Add new network block
        network_block = f'''
network={{
    ssid="{ssid}"
    psk="{password}"
    priority={priority}
}}
'''
        config_content += network_block
        
        # Write config
        with open(WPA_SUPPLICANT_FILE, 'w') as f:
            f.write(config_content)
        
        # Reconfigure interface
        subprocess.run(['sudo', 'wpa_cli', '-i', 'wlan0', 'reconfigure'],
                      capture_output=True, timeout=30)
        return True, "WiFi configured"
    except Exception as e:
        return False, str(e)


def get_wifi_config():
    """Get saved WiFi configuration."""
    config = {
        'main': {'ssid': '', 'password': '', 'country': 'FR'},
        'fallback': {'ssid': '', 'password': ''}
    }
    try:
        if NETWORK_MANAGER_AVAILABLE:
            # Get saved connections
            result = subprocess.run(
                ['nmcli', '-t', '-f', 'NAME,TYPE', 'con', 'show'],
                capture_output=True, text=True, timeout=10
            )
            wifi_connections = []
            for line in result.stdout.strip().split('\n'):
                parts = line.split(':')
                if len(parts) >= 2 and parts[1] == '802-11-wireless':
                    wifi_connections.append(parts[0])
            
            if wifi_connections:
                config['main']['ssid'] = wifi_connections[0]
                if len(wifi_connections) > 1:
                    config['fallback']['ssid'] = wifi_connections[1]
    except Exception as e:
        print(f"Error getting WiFi config: {e}")
    return config


# ============================================================================
# RTSP Camera Watchdog
# ============================================================================

# RTSP watchdog state
rtsp_watchdog_state = {
    'running': False,
    'last_check': None,
    'last_healthy': None,
    'restart_count': 0,
    'last_restart': None
}
rtsp_watchdog_lock = threading.Lock()
rtsp_watchdog_stop_event = threading.Event()


def find_camera_device():
    """Find the best available camera device.
    
    Priority:
    1. /dev/camera (udev symlink)
    2. Configured VIDEO_DEVICE
    3. Auto-detect USB webcam
    """
    # Priority 1: udev symlink
    if os.path.exists('/dev/camera'):
        return '/dev/camera'
    
    # Priority 2: Configured device
    config = load_config()
    configured = config.get('VIDEO_DEVICE', '/dev/video0')
    if os.path.exists(configured):
        # Verify it's a capture device
        try:
            result = subprocess.run(
                ['v4l2-ctl', '-d', configured, '--all'],
                capture_output=True, text=True, timeout=5
            )
            if 'Video Capture' in result.stdout:
                return configured
        except:
            pass
    
    # Priority 3: Auto-detect
    try:
        result = subprocess.run(
            ['v4l2-ctl', '--list-devices'],
            capture_output=True, text=True, timeout=10
        )
        lines = result.stdout.split('\n')
        in_usb_cam = False
        for line in lines:
            if 'usb' in line.lower() and ('cam' in line.lower() or 'lifecam' in line.lower()):
                in_usb_cam = True
            elif in_usb_cam and line.strip().startswith('/dev/video'):
                device = line.strip()
                if os.path.exists(device):
                    return device
            elif line and not line.startswith('\t') and not line.startswith(' '):
                in_usb_cam = False
    except:
        pass
    
    # Fallback: try video0-4
    for i in range(5):
        dev = f'/dev/video{i}'
        if os.path.exists(dev):
            try:
                result = subprocess.run(
                    ['v4l2-ctl', '-d', dev, '--all'],
                    capture_output=True, text=True, timeout=5
                )
                if 'Video Capture' in result.stdout and 'uvcvideo' in result.stdout:
                    return dev
            except:
                continue
    
    return None


def check_rtsp_service_health():
    """Check if RTSP service is healthy (running and streaming).
    
    Returns: (healthy: bool, reason: str)
    """
    try:
        # Check 1: Is service active?
        result = subprocess.run(
            ['systemctl', 'is-active', 'rpi-av-rtsp-recorder'],
            capture_output=True, text=True, timeout=5
        )
        if result.stdout.strip() != 'active':
            return False, f"Service not active: {result.stdout.strip()}"
        
        # Check 2: Is camera device available?
        camera = find_camera_device()
        if not camera:
            return False, "No camera device found"
        
        # Check 3: Is test-launch process running?
        result = subprocess.run(
            ['pgrep', '-f', 'test-launch'],
            capture_output=True, text=True, timeout=5
        )
        if result.returncode != 0:
            return False, "test-launch process not running"
        
        # Check 4: Can we read from the camera? (quick test)
        result = subprocess.run(
            ['v4l2-ctl', '-d', camera, '--get-fmt-video'],
            capture_output=True, text=True, timeout=5
        )
        if result.returncode != 0:
            return False, f"Cannot read camera format: {result.stderr}"
        
        return True, "Healthy"
    except Exception as e:
        return False, f"Health check error: {e}"


def restart_rtsp_service(reason=""):
    """Restart the RTSP service with proper camera device."""
    try:
        camera = find_camera_device()
        print(f"[RTSP Watchdog] Restarting service. Reason: {reason}")
        print(f"[RTSP Watchdog] Camera device: {camera}")
        
        # Update config with detected camera if needed
        if camera and camera != '/dev/camera':
            config = load_config()
            if config.get('VIDEO_DEVICE') != camera:
                print(f"[RTSP Watchdog] Updating VIDEO_DEVICE to {camera}")
                config['VIDEO_DEVICE'] = camera
                save_config(config)
        
        # Stop service
        subprocess.run(['sudo', 'systemctl', 'stop', 'rpi-av-rtsp-recorder'],
                      capture_output=True, timeout=10)
        time.sleep(1)
        
        # Start service
        result = subprocess.run(['sudo', 'systemctl', 'start', 'rpi-av-rtsp-recorder'],
                               capture_output=True, text=True, timeout=30)
        
        if result.returncode == 0:
            print("[RTSP Watchdog] Service restarted successfully")
            with rtsp_watchdog_lock:
                rtsp_watchdog_state['restart_count'] += 1
                rtsp_watchdog_state['last_restart'] = time.time()
            return True
        else:
            print(f"[RTSP Watchdog] Restart failed: {result.stderr}")
            return False
    except Exception as e:
        print(f"[RTSP Watchdog] Restart error: {e}")
        return False


def rtsp_watchdog_loop():
    """Background thread that monitors RTSP service health.
    
    Check interval: 5 seconds
    Max recovery time target: < 15 seconds
    """
    print("[RTSP Watchdog] Starting...")
    CHECK_INTERVAL = 5  # Check every 5 seconds
    UNHEALTHY_THRESHOLD = 2  # Restart after 2 consecutive failures (10s)
    
    consecutive_failures = 0
    
    while not rtsp_watchdog_stop_event.is_set():
        try:
            healthy, reason = check_rtsp_service_health()
            
            with rtsp_watchdog_lock:
                rtsp_watchdog_state['last_check'] = time.time()
            
            if healthy:
                consecutive_failures = 0
                with rtsp_watchdog_lock:
                    rtsp_watchdog_state['last_healthy'] = time.time()
            else:
                consecutive_failures += 1
                print(f"[RTSP Watchdog] Unhealthy ({consecutive_failures}/{UNHEALTHY_THRESHOLD}): {reason}")
                
                if consecutive_failures >= UNHEALTHY_THRESHOLD:
                    # Time to restart
                    restart_rtsp_service(reason)
                    consecutive_failures = 0
                    # Wait a bit after restart
                    time.sleep(5)
            
        except Exception as e:
            print(f"[RTSP Watchdog] Error: {e}")
        
        rtsp_watchdog_stop_event.wait(CHECK_INTERVAL)
    
    print("[RTSP Watchdog] Stopped")


def start_rtsp_watchdog():
    """Start the RTSP watchdog thread."""
    with rtsp_watchdog_lock:
        if rtsp_watchdog_state.get('running'):
            print("[RTSP Watchdog] Already running")
            return False
    
    rtsp_watchdog_stop_event.clear()
    thread = threading.Thread(target=rtsp_watchdog_loop, daemon=True)
    thread.start()
    
    with rtsp_watchdog_lock:
        rtsp_watchdog_state['running'] = True
    
    print("[RTSP Watchdog] Started")
    return True


def stop_rtsp_watchdog():
    """Stop the RTSP watchdog thread."""
    with rtsp_watchdog_lock:
        if not rtsp_watchdog_state.get('running'):
            return False
    
    rtsp_watchdog_stop_event.set()
    time.sleep(1)
    
    with rtsp_watchdog_lock:
        rtsp_watchdog_state['running'] = False
    
    print("[RTSP Watchdog] Stopped")
    return True


# ============================================================================
# WiFi Failover Management Functions
# ============================================================================

# WiFi failover configuration file
WIFI_FAILOVER_CONFIG_FILE = '/etc/rpi-cam/wifi_failover.json'

# WiFi failover state
wifi_failover_state = {
    'active_interface': None,
    'primary_interface': None,
    'secondary_interface': None,
    'failover_enabled': False,
    'last_check': None,
    'watchdog_running': False
}
wifi_failover_lock = threading.Lock()
wifi_failover_stop_event = threading.Event()


def wifi_failover_watchdog_loop():
    """Background thread that monitors WiFi interfaces and triggers failover if needed.
    
    Uses adaptive interval: quick checks after changes, slower in stable state.
    """
    print("[WiFi Failover Watchdog] Starting...")
    
    last_interfaces_hash = None  # To detect interface changes
    quick_check_count = 0  # For rapid checks after changes
    
    while not wifi_failover_stop_event.is_set():
        try:
            config = load_wifi_failover_config()
            base_interval = max(5, config.get('check_interval', 10))  # Minimum 5s, default 10s
            
            # Use quick interval (2s) after detecting changes, otherwise base interval
            if quick_check_count > 0:
                check_interval = 2
                quick_check_count -= 1
            else:
                check_interval = base_interval
            
            # Only run if hardware failover is enabled
            if not config.get('hardware_failover_enabled', True):
                wifi_failover_stop_event.wait(check_interval)
                continue
            
            primary_iface = config.get('primary_interface', 'wlan1')
            secondary_iface = config.get('secondary_interface', 'wlan0')
            
            # Get current interface states
            wifi_interfaces = get_wifi_interfaces()
            wifi_by_name = {iface['name']: iface for iface in wifi_interfaces}
            
            # Create a hash of current interface state to detect changes
            current_hash = str([
                (iface.get('name'), iface.get('phy_exists'), iface.get('connected'))
                for iface in wifi_interfaces
            ])
            
            # Detect if interfaces changed (USB added/removed)
            interfaces_changed = (last_interfaces_hash is not None and 
                                  current_hash != last_interfaces_hash)
            last_interfaces_hash = current_hash
            
            if interfaces_changed:
                print(f"[WiFi Failover Watchdog] Interface change detected!")
                quick_check_count = 5  # Do 5 quick checks after change
            
            primary_info = wifi_by_name.get(primary_iface, {})
            secondary_info = wifi_by_name.get(secondary_iface, {})
            
            primary_connected = primary_info.get('connected', False) and primary_info.get('ssid')
            secondary_connected = secondary_info.get('connected', False) and secondary_info.get('ssid')
            primary_available = primary_info.get('phy_exists', False)
            secondary_available = secondary_info.get('phy_exists', False)
            
            # Current state
            with wifi_failover_lock:
                current_active = wifi_failover_state.get('active_interface')
            
            # Sync current_active with reality if not set
            if not current_active:
                if primary_connected:
                    current_active = primary_iface
                elif secondary_connected:
                    current_active = secondary_iface
                with wifi_failover_lock:
                    wifi_failover_state['active_interface'] = current_active
            
            # Determine if failover is needed
            needs_failover = False
            reason = ''
            
            # Case 1: No WiFi connected at all
            if not primary_connected and not secondary_connected:
                needs_failover = True
                reason = 'No WiFi interface connected'
            
            # Case 2: Currently on secondary but primary interface is back (and not connected)
            # This triggers a switch back to primary
            elif secondary_connected and primary_available and not primary_connected:
                needs_failover = True
                reason = f'Primary interface {primary_iface} is back - switching from {secondary_iface}'
            
            # Case 3: Primary was connected but disappeared
            elif current_active == primary_iface and not primary_connected and not primary_available:
                needs_failover = True
                reason = f'Primary interface {primary_iface} disconnected/removed'
            
            # Case 4: BOTH interfaces connected - this should never happen, disconnect secondary
            elif primary_connected and secondary_connected:
                print(f"[WiFi Failover Watchdog] Both interfaces connected - disconnecting {secondary_iface}")
                try:
                    subprocess.run(['sudo', 'nmcli', 'device', 'disconnect', secondary_iface],
                                  capture_output=True, timeout=10)
                    with wifi_failover_lock:
                        wifi_failover_state['active_interface'] = primary_iface
                    print(f"[WiFi Failover Watchdog] Disconnected {secondary_iface}, keeping {primary_iface}")
                except Exception as e:
                    print(f"[WiFi Failover Watchdog] Failed to disconnect {secondary_iface}: {e}")
            
            if needs_failover:
                print(f"[WiFi Failover Watchdog] Failover needed: {reason}")
                result = perform_wifi_failover()
                print(f"[WiFi Failover Watchdog] Result: {result.get('action')} - {result.get('reason')}")
            
            with wifi_failover_lock:
                wifi_failover_state['last_check'] = time.time()
            
        except Exception as e:
            print(f"[WiFi Failover Watchdog] Error: {e}")
        
        # Wait for next check
        wifi_failover_stop_event.wait(check_interval)
    
    print("[WiFi Failover Watchdog] Stopped")


def start_wifi_failover_watchdog():
    """Start the WiFi failover watchdog thread."""
    global wifi_failover_stop_event
    
    with wifi_failover_lock:
        if wifi_failover_state.get('watchdog_running'):
            print("[WiFi Failover Watchdog] Already running")
            return False
    
    wifi_failover_stop_event.clear()
    thread = threading.Thread(target=wifi_failover_watchdog_loop, daemon=True)
    thread.start()
    
    with wifi_failover_lock:
        wifi_failover_state['watchdog_running'] = True
    
    print("[WiFi Failover Watchdog] Started")
    return True


def stop_wifi_failover_watchdog():
    """Stop the WiFi failover watchdog thread."""
    global wifi_failover_stop_event
    
    wifi_failover_stop_event.set()
    
    with wifi_failover_lock:
        wifi_failover_state['watchdog_running'] = False
    
    print("[WiFi Failover Watchdog] Stop requested")
    return True


def load_wifi_failover_config():
    """Load WiFi failover configuration."""
    default_config = {
        # Hardware failover (which interface to use)
        'hardware_failover_enabled': True,
        'primary_interface': 'wlan1',      # USB dongle (priority)
        'secondary_interface': 'wlan0',    # Built-in WiFi (backup)
        
        # Network failover (which SSID to use)
        'network_failover_enabled': True,
        'primary_ssid': '',
        'primary_password': '',
        'secondary_ssid': '',              # Fallback network
        'secondary_password': '',
        
        # Shared IP configuration (applied to whichever interface is active)
        'ip_mode': 'dhcp',                 # 'dhcp' or 'static'
        'static_ip': '',
        'gateway': '',
        'dns': '8.8.8.8',
        
        'check_interval': 30               # seconds between checks
    }
    try:
        if os.path.exists(WIFI_FAILOVER_CONFIG_FILE):
            with open(WIFI_FAILOVER_CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Merge with defaults (handle old config format)
                for key in default_config:
                    if key not in config:
                        config[key] = default_config[key]
                # Migration from old format
                if 'ssid' in config and 'primary_ssid' not in config:
                    config['primary_ssid'] = config.get('ssid', '')
                    config['primary_password'] = config.get('password', '')
                if 'enabled' in config:
                    config['hardware_failover_enabled'] = config.get('enabled', True)
                return config
    except Exception as e:
        print(f"[WiFi Failover] Error loading config: {e}")
    return default_config


def save_wifi_failover_config(config):
    """Save WiFi failover configuration."""
    try:
        os.makedirs(os.path.dirname(WIFI_FAILOVER_CONFIG_FILE), exist_ok=True)
        with open(WIFI_FAILOVER_CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
        return True
    except Exception as e:
        print(f"[WiFi Failover] Error saving config: {e}")
        return False


def get_wifi_interfaces():
    """Get all WiFi interfaces and their status."""
    wifi_interfaces = []
    
    # Get active connection names for wifi devices
    conn_by_device = {}
    try:
        result = subprocess.run(
            ['nmcli', '-t', '-f', 'GENERAL.CONNECTION,GENERAL.DEVICE', 'device', 'show'],
            capture_output=True, text=True, timeout=10
        )
        # Parse pairs of lines
        lines = result.stdout.strip().split('\n')
        current_conn = None
        for line in lines:
            if line.startswith('GENERAL.CONNECTION:'):
                current_conn = line.split(':', 1)[1] if ':' in line else None
            elif line.startswith('GENERAL.DEVICE:'):
                device = line.split(':', 1)[1] if ':' in line else None
                if device and current_conn and current_conn != '--':
                    conn_by_device[device] = current_conn
    except Exception as e:
        print(f"[WiFi Failover] Error getting connection names: {e}")
    
    # Get real SSID from connection profiles
    real_ssid_by_device = {}
    for device, conn_name in conn_by_device.items():
        try:
            result = subprocess.run(
                ['nmcli', '-t', '-f', '802-11-wireless.ssid', 'con', 'show', conn_name],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                # Format: "802-11-wireless.ssid:SSID_NAME"
                ssid_line = result.stdout.strip()
                if ':' in ssid_line:
                    real_ssid_by_device[device] = ssid_line.split(':', 1)[1]
        except Exception as e:
            print(f"[WiFi Failover] Error getting SSID for {device}: {e}")
    
    try:
        interfaces = get_network_interfaces()
        for iface in interfaces:
            if iface['type'] == 'wifi':
                # Check if interface physically exists (device connected)
                phy_exists = os.path.exists(f"/sys/class/net/{iface['name']}")
                
                # Use real SSID from nmcli connection info
                ssid = real_ssid_by_device.get(iface['name'], '')
                
                # Get additional WiFi info
                wifi_info = {
                    'name': iface['name'],
                    'connected': iface.get('connected', False) or bool(ssid),
                    'ip': iface.get('ip', ''),
                    'ssid': ssid,
                    'mac': iface.get('mac', ''),
                    'phy_exists': phy_exists,
                    'state': iface.get('state', 'unknown')
                }
                
                # Check if it's USB or built-in
                try:
                    phy_path = os.path.realpath(f"/sys/class/net/{iface['name']}/device")
                    wifi_info['is_usb'] = 'usb' in phy_path.lower()
                except:
                    wifi_info['is_usb'] = False
                
                wifi_interfaces.append(wifi_info)
    except Exception as e:
        print(f"[WiFi Failover] Error getting WiFi interfaces: {e}")
    return wifi_interfaces


def get_active_wifi_interface():
    """Get the currently active (connected) WiFi interface according to failover priority."""
    try:
        config = load_wifi_failover_config()
        primary = config.get('primary_interface', 'wlan1')
        secondary = config.get('secondary_interface', 'wlan0')
        
        wifi_interfaces = get_wifi_interfaces()
        wifi_by_name = {iface['name']: iface for iface in wifi_interfaces}
        
        # Return primary if connected, else secondary if connected
        if primary in wifi_by_name and wifi_by_name[primary].get('connected') and wifi_by_name[primary].get('ssid'):
            return wifi_by_name[primary]
        if secondary in wifi_by_name and wifi_by_name[secondary].get('connected') and wifi_by_name[secondary].get('ssid'):
            return wifi_by_name[secondary]
        
        # Fallback: return any connected interface
        for iface in wifi_interfaces:
            if iface['connected'] and iface['ssid']:
                return iface
    except Exception as e:
        print(f"[WiFi Failover] Error getting active interface: {e}")
    return None


def disconnect_wifi_interface(interface_name):
    """Disconnect a WiFi interface."""
    try:
        if not NETWORK_MANAGER_AVAILABLE:
            return False, "NetworkManager not available"
        
        # Find and disconnect any connection on this interface
        result = subprocess.run(
            ['nmcli', '-t', '-f', 'NAME,DEVICE', 'con', 'show', '--active'],
            capture_output=True, text=True, timeout=10
        )
        
        for line in result.stdout.strip().split('\n'):
            if line:
                parts = line.split(':')
                if len(parts) >= 2 and parts[1] == interface_name:
                    conn_name = parts[0]
                    subprocess.run(
                        ['sudo', 'nmcli', 'con', 'down', conn_name],
                        capture_output=True, timeout=30
                    )
                    print(f"[WiFi Failover] Disconnected {conn_name} on {interface_name}")
        
        return True, f"Disconnected {interface_name}"
    except Exception as e:
        return False, str(e)


def connect_wifi_on_interface(interface_name, ssid, password, ip_config=None):
    """Connect a specific WiFi interface to an SSID with optional IP config.
    
    Strategy:
    1. First try to find and use an existing connection profile for this SSID
    2. If no existing profile or it fails, create a new one (requires password)
    
    ip_config: dict with 'mode' ('dhcp'/'static'), 'ip', 'gateway', 'dns'
    """
    try:
        if not NETWORK_MANAGER_AVAILABLE:
            return False, "NetworkManager not available"
        
        # Check if interface exists
        if not os.path.exists(f"/sys/class/net/{interface_name}"):
            return False, f"Interface {interface_name} not found"
        
        # Request a WiFi scan first to ensure the network is visible
        subprocess.run(
            ['sudo', 'nmcli', 'device', 'wifi', 'rescan', 'ifname', interface_name],
            capture_output=True, timeout=10
        )
        time.sleep(2)  # Give time for scan results
        
        # Strategy 1: Try to find existing connection profile for this SSID
        existing_conn = None
        try:
            result = subprocess.run(
                ['nmcli', '-t', '-f', 'NAME,TYPE', 'con', 'show'],
                capture_output=True, text=True, timeout=10
            )
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split(':')
                    if len(parts) >= 2 and parts[1] == '802-11-wireless':
                        conn_name = parts[0]
                        # Check if this connection is for our SSID
                        ssid_result = subprocess.run(
                            ['nmcli', '-t', '-f', '802-11-wireless.ssid', 'con', 'show', conn_name],
                            capture_output=True, text=True, timeout=5
                        )
                        if ssid_result.returncode == 0:
                            conn_ssid = ssid_result.stdout.strip().split(':', 1)[-1] if ':' in ssid_result.stdout else ''
                            if conn_ssid == ssid:
                                existing_conn = conn_name
                                print(f"[WiFi Failover] Found existing connection '{conn_name}' for SSID '{ssid}'")
                                break
        except Exception as e:
            print(f"[WiFi Failover] Error searching for existing connections: {e}")
        
        # Try to activate existing connection first
        if existing_conn:
            print(f"[WiFi Failover] Trying existing connection '{existing_conn}' on {interface_name}...")
            
            # Apply IP configuration to existing profile BEFORE connecting
            if ip_config:
                print(f"[WiFi Failover] Applying IP config to existing profile: {ip_config.get('mode')}")
                if ip_config.get('mode') == 'static' and ip_config.get('ip'):
                    static_ip = ip_config.get('ip', '')
                    gateway = ip_config.get('gateway', '')
                    dns = ip_config.get('dns', '8.8.8.8')
                    
                    # Ensure IP has CIDR notation
                    if '/' not in static_ip:
                        static_ip = f"{static_ip}/24"
                    
                    subprocess.run([
                        'sudo', 'nmcli', 'con', 'modify', existing_conn,
                        'ipv4.method', 'manual',
                        'ipv4.addresses', static_ip,
                        'ipv4.gateway', gateway,
                        'ipv4.dns', dns
                    ], capture_output=True, timeout=10)
                    print(f"[WiFi Failover] Applied static IP {static_ip} to {existing_conn}")
                else:
                    # DHCP mode
                    subprocess.run([
                        'sudo', 'nmcli', 'con', 'modify', existing_conn,
                        'ipv4.method', 'auto',
                        'ipv4.addresses', '',
                        'ipv4.gateway', '',
                        'ipv4.dns', ''
                    ], capture_output=True, timeout=10)
                    print(f"[WiFi Failover] Applied DHCP to {existing_conn}")
            
            result = subprocess.run(
                ['sudo', 'nmcli', 'con', 'up', existing_conn, 'ifname', interface_name],
                capture_output=True, text=True, timeout=60
            )
            if result.returncode == 0:
                print(f"[WiFi Failover] Successfully connected using existing profile")
                return True, f"Connected {interface_name} to {ssid} (existing profile, IP: {ip_config.get('mode') if ip_config else 'default'})"
            else:
                print(f"[WiFi Failover] Existing connection failed: {result.stderr}")
        
        # Strategy 2: Create new connection (requires password)
        if not password:
            return False, f"No existing connection found for '{ssid}' and no password provided"
        
        # Connection name (unique per interface)
        con_name = f"wifi-failover-{interface_name}"
        
        # Delete existing failover connection if any
        subprocess.run(
            ['sudo', 'nmcli', 'con', 'delete', con_name],
            capture_output=True, timeout=10
        )
        
        # Create new connection
        print(f"[WiFi Failover] Creating new connection '{con_name}' for SSID '{ssid}'...")
        cmd = [
            'sudo', 'nmcli', 'con', 'add',
            'type', 'wifi',
            'con-name', con_name,
            'ifname', interface_name,
            'ssid', ssid,
            'connection.autoconnect', 'no'  # We manage this manually
        ]
        
        cmd.extend([
            'wifi-sec.key-mgmt', 'wpa-psk',
            'wifi-sec.psk', password
        ])
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        if result.returncode != 0:
            return False, f"Failed to create connection: {result.stderr}"
        
        # Configure IP settings
        if ip_config and ip_config.get('mode') == 'static':
            static_ip = ip_config.get('ip', '')
            gateway = ip_config.get('gateway', '')
            dns = ip_config.get('dns', '8.8.8.8')
            
            if static_ip:
                # Ensure CIDR notation
                if '/' not in static_ip:
                    static_ip = f"{static_ip}/24"
                    
                subprocess.run([
                    'sudo', 'nmcli', 'con', 'modify', con_name,
                    'ipv4.method', 'manual',
                    'ipv4.addresses', static_ip,
                    'ipv4.gateway', gateway,
                    'ipv4.dns', dns
                ], capture_output=True, timeout=10)
                print(f"[WiFi Failover] Applied static IP {static_ip} to new profile {con_name}")
        else:
            subprocess.run([
                'sudo', 'nmcli', 'con', 'modify', con_name,
                'ipv4.method', 'auto'
            ], capture_output=True, timeout=10)
        
        # Activate connection
        result = subprocess.run(
            ['sudo', 'nmcli', 'con', 'up', con_name],
            capture_output=True, text=True, timeout=60
        )
        
        if result.returncode != 0:
            return False, f"Failed to connect: {result.stderr}"
        
        return True, f"Connected {interface_name} to {ssid} (new profile)"
    except Exception as e:
        return False, str(e)


def perform_wifi_failover():
    """Apply WiFi failover configuration.
    
    Two-level failover:
    1. HARDWARE FAILOVER: If primary interface (wlan1) unavailable → use secondary (wlan0)
    2. NETWORK FAILOVER: If primary SSID unavailable → try secondary SSID
    
    Only ONE interface is connected at a time.
    """
    config = load_wifi_failover_config()
    
    primary_iface = config.get('primary_interface', 'wlan1')
    secondary_iface = config.get('secondary_interface', 'wlan0')
    primary_ssid = config.get('primary_ssid', '')
    primary_password = config.get('primary_password', '')
    secondary_ssid = config.get('secondary_ssid', '')
    secondary_password = config.get('secondary_password', '')
    
    hardware_failover = config.get('hardware_failover_enabled', True)
    network_failover = config.get('network_failover_enabled', True)
    
    ip_config = {
        'mode': config.get('ip_mode', 'dhcp'),
        'ip': config.get('static_ip', ''),
        'gateway': config.get('gateway', ''),
        'dns': config.get('dns', '8.8.8.8')
    }
    
    result = {
        'action': 'none',
        'reason': '',
        'active_interface': None,
        'active_ssid': None,
        'disconnected': [],
        'attempts': []
    }
    
    if not primary_ssid:
        result['reason'] = 'No primary SSID configured'
        return result
    
    # Get current interface status
    wifi_interfaces = get_wifi_interfaces()
    wifi_by_name = {iface['name']: iface for iface in wifi_interfaces}
    
    primary_iface_available = wifi_by_name.get(primary_iface, {}).get('phy_exists', False)
    secondary_iface_available = wifi_by_name.get(secondary_iface, {}).get('phy_exists', False)
    
    # Step 1: Disconnect ALL WiFi interfaces first (clean slate)
    for iface_name in [primary_iface, secondary_iface]:
        if iface_name in wifi_by_name and wifi_by_name[iface_name].get('connected'):
            print(f"[WiFi Failover] Disconnecting {iface_name}...")
            disconnect_wifi_interface(iface_name)
            result['disconnected'].append(iface_name)
            time.sleep(1)
    
    # Step 2: Determine which interface to use (Hardware Failover)
    if hardware_failover:
        interfaces_to_try = []
        if primary_iface_available:
            interfaces_to_try.append(primary_iface)
        if secondary_iface_available:
            interfaces_to_try.append(secondary_iface)
    else:
        # Only use primary interface
        interfaces_to_try = [primary_iface] if primary_iface_available else []
    
    if not interfaces_to_try:
        result['reason'] = 'No WiFi interface physically available'
        return result
    
    # Step 3: Determine which networks to try (Network Failover)
    if network_failover and secondary_ssid:
        networks_to_try = [
            (primary_ssid, primary_password),
            (secondary_ssid, secondary_password)
        ]
    else:
        networks_to_try = [(primary_ssid, primary_password)]
    
    # Step 4: Try each interface with each network until one works
    connected = False
    for iface in interfaces_to_try:
        if connected:
            break
        for ssid, password in networks_to_try:
            if connected:
                break
            
            attempt = {'interface': iface, 'ssid': ssid}
            print(f"[WiFi Failover] Trying {iface} → {ssid}...")
            
            success, msg = connect_wifi_on_interface(iface, ssid, password, ip_config)
            attempt['success'] = success
            attempt['message'] = msg
            result['attempts'].append(attempt)
            
            if success:
                connected = True
                result['active_interface'] = iface
                result['active_ssid'] = ssid
                
                # Determine action type
                is_primary_iface = (iface == primary_iface)
                is_primary_ssid = (ssid == primary_ssid)
                
                if is_primary_iface and is_primary_ssid:
                    result['action'] = 'connected_primary'
                    result['reason'] = f'Connected to {ssid} via {iface} (primary)'
                elif is_primary_iface and not is_primary_ssid:
                    result['action'] = 'network_failover'
                    result['reason'] = f'Primary network unavailable, connected to {ssid} via {iface}'
                elif not is_primary_iface and is_primary_ssid:
                    result['action'] = 'hardware_failover'
                    result['reason'] = f'Primary interface unavailable, connected to {ssid} via {iface}'
                else:
                    result['action'] = 'full_failover'
                    result['reason'] = f'Both primary interface and network unavailable, connected to {ssid} via {iface}'
                
                print(f"[WiFi Failover] {result['reason']}")
                break
            else:
                print(f"[WiFi Failover] Failed: {msg}")
    
    if not connected:
        result['reason'] = 'Failed to connect to any network on any interface'
    
    # Update state
    with wifi_failover_lock:
        wifi_failover_state['active_interface'] = result.get('active_interface')
        wifi_failover_state['last_check'] = time.time()
    
    return result


def get_wifi_failover_status():
    """Get current WiFi failover status."""
    config = load_wifi_failover_config()
    wifi_interfaces = get_wifi_interfaces()
    active = get_active_wifi_interface()
    
    with wifi_failover_lock:
        watchdog_running = wifi_failover_state.get('watchdog_running', False)
        last_check = wifi_failover_state.get('last_check')
    
    return {
        # Hardware failover settings
        'hardware_failover_enabled': config.get('hardware_failover_enabled', True),
        'primary_interface': config.get('primary_interface', 'wlan1'),
        'secondary_interface': config.get('secondary_interface', 'wlan0'),
        
        # Network failover settings
        'network_failover_enabled': config.get('network_failover_enabled', True),
        'primary_ssid': config.get('primary_ssid', ''),
        'secondary_ssid': config.get('secondary_ssid', ''),
        
        # Password indicators (don't expose actual passwords)
        'has_primary_password': bool(config.get('primary_password', '')),
        'has_secondary_password': bool(config.get('secondary_password', '')),
        
        # IP settings
        'ip_mode': config.get('ip_mode', 'dhcp'),
        'static_ip': config.get('static_ip', ''),
        'gateway': config.get('gateway', ''),
        'dns': config.get('dns', '8.8.8.8'),
        
        # Watchdog state
        'watchdog_running': watchdog_running,
        'watchdog_last_check': last_check,
        'check_interval': config.get('check_interval', 30),
        
        # Current state
        'active_interface': active.get('name') if active else None,
        'active_ssid': active.get('ssid') if active else None,
        'active_ip': active.get('ip') if active else None,
        'wifi_interfaces': wifi_interfaces
    }


# ============================================================================
# Network Interface Management Functions
# ============================================================================

def get_network_interfaces():
    """Get list of all network interfaces with their status."""
    interfaces = []
    try:
        # Get list of interfaces
        result = subprocess.run(
            ['ip', '-j', 'link', 'show'],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            import json
            links = json.loads(result.stdout)
            for link in links:
                name = link.get('ifname', '')
                if name == 'lo':  # Skip loopback
                    continue
                
                iface = {
                    'name': name,
                    'type': 'unknown',
                    'state': link.get('operstate', 'unknown'),
                    'mac': link.get('address', ''),
                    'ip': '',
                    'connected': link.get('operstate', '').lower() == 'up'
                }
                
                # Determine type
                if name.startswith('eth'):
                    iface['type'] = 'ethernet'
                elif name.startswith('wlan'):
                    iface['type'] = 'wifi'
                elif name.startswith('usb'):
                    iface['type'] = 'usb'
                
                # Get IP address
                try:
                    ip_result = subprocess.run(
                        ['ip', '-j', 'addr', 'show', name],
                        capture_output=True, text=True, timeout=5
                    )
                    if ip_result.returncode == 0:
                        addrs = json.loads(ip_result.stdout)
                        for addr in addrs:
                            for addr_info in addr.get('addr_info', []):
                                if addr_info.get('family') == 'inet':
                                    iface['ip'] = f"{addr_info.get('local', '')}/{addr_info.get('prefixlen', '')}"
                                    break
                except:
                    pass
                
                # Get WiFi SSID if connected
                if iface['type'] == 'wifi' and iface['connected']:
                    try:
                        ssid_result = subprocess.run(
                            ['iwgetid', '-r', name],
                            capture_output=True, text=True, timeout=5
                        )
                        if ssid_result.returncode == 0:
                            iface['ssid'] = ssid_result.stdout.strip()
                    except:
                        pass
                
                interfaces.append(iface)
    except Exception as e:
        print(f"Error getting network interfaces: {e}")
        # Fallback method
        try:
            result = subprocess.run(['ip', 'link', 'show'], capture_output=True, text=True, timeout=10)
            for line in result.stdout.split('\n'):
                match = re.match(r'^\d+:\s+(\w+):', line)
                if match and match.group(1) != 'lo':
                    interfaces.append({
                        'name': match.group(1),
                        'type': 'wifi' if match.group(1).startswith('wlan') else 'ethernet',
                        'state': 'unknown',
                        'mac': '',
                        'ip': '',
                        'connected': False
                    })
        except:
            pass
    
    return interfaces


def get_interface_priority():
    """Get the current interface priority order from NetworkManager metrics."""
    priority = []
    try:
        # Get all connections with their metrics
        result = subprocess.run(
            ['nmcli', '-t', '-f', 'NAME,DEVICE,TYPE', 'con', 'show', '--active'],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split(':')
                    if len(parts) >= 2 and parts[1]:
                        priority.append(parts[1])
    except Exception as e:
        print(f"Error getting interface priority: {e}")
    
    return priority


def set_interface_priority(interfaces_order):
    """Set network interface priority using NetworkManager metrics.
    
    Lower metric = higher priority
    interfaces_order: list of interface names in priority order
    """
    try:
        base_metric = 100
        for i, iface in enumerate(interfaces_order):
            metric = base_metric + (i * 100)
            
            # Find connection name for this device
            result = subprocess.run(
                ['nmcli', '-t', '-f', 'NAME,DEVICE', 'con', 'show'],
                capture_output=True, text=True, timeout=10
            )
            
            for line in result.stdout.strip().split('\n'):
                parts = line.split(':')
                if len(parts) >= 2 and parts[1] == iface:
                    conn_name = parts[0]
                    # Set route metric
                    subprocess.run(
                        ['sudo', 'nmcli', 'con', 'modify', conn_name, 
                         'ipv4.route-metric', str(metric),
                         'ipv6.route-metric', str(metric)],
                        capture_output=True, timeout=10
                    )
                    break
        
        return True, "Interface priority updated"
    except Exception as e:
        return False, str(e)


def get_network_config():
    """Get current network configuration."""
    config = {
        'mode': 'dhcp',
        'static_ip': '',
        'gateway': '',
        'dns': '8.8.8.8',
        'interfaces': get_network_interfaces(),
        'priority': get_interface_priority()
    }
    
    try:
        # Check if any interface has static IP
        result = subprocess.run(
            ['nmcli', '-t', '-f', 'NAME,ipv4.method,ipv4.addresses,ipv4.gateway,ipv4.dns', 
             'con', 'show'],
            capture_output=True, text=True, timeout=10
        )
        # Parse result if needed
    except Exception as e:
        print(f"Error getting network config: {e}")
    
    return config


def configure_static_ip(interface, ip_address, gateway, dns):
    """Configure static IP on an interface."""
    try:
        if not NETWORK_MANAGER_AVAILABLE:
            return False, "NetworkManager not available"
        
        # Find connection for interface
        result = subprocess.run(
            ['nmcli', '-t', '-f', 'NAME,DEVICE', 'con', 'show'],
            capture_output=True, text=True, timeout=10
        )
        
        conn_name = None
        for line in result.stdout.strip().split('\n'):
            parts = line.split(':')
            if len(parts) >= 2 and parts[1] == interface:
                conn_name = parts[0]
                break
        
        if not conn_name:
            return False, f"No connection found for {interface}"
        
        # Configure static IP
        commands = [
            ['sudo', 'nmcli', 'con', 'modify', conn_name, 'ipv4.method', 'manual'],
            ['sudo', 'nmcli', 'con', 'modify', conn_name, 'ipv4.addresses', ip_address],
            ['sudo', 'nmcli', 'con', 'modify', conn_name, 'ipv4.gateway', gateway],
            ['sudo', 'nmcli', 'con', 'modify', conn_name, 'ipv4.dns', dns],
        ]
        
        for cmd in commands:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return False, f"Failed: {' '.join(cmd)}: {result.stderr}"
        
        # Restart connection
        subprocess.run(['sudo', 'nmcli', 'con', 'down', conn_name], 
                      capture_output=True, timeout=10)
        subprocess.run(['sudo', 'nmcli', 'con', 'up', conn_name], 
                      capture_output=True, timeout=10)
        
        return True, "Static IP configured"
    except Exception as e:
        return False, str(e)


def configure_dhcp(interface):
    """Configure DHCP on an interface."""
    try:
        if not NETWORK_MANAGER_AVAILABLE:
            return False, "NetworkManager not available"
        
        # Find connection for interface
        result = subprocess.run(
            ['nmcli', '-t', '-f', 'NAME,DEVICE', 'con', 'show'],
            capture_output=True, text=True, timeout=10
        )
        
        conn_name = None
        for line in result.stdout.strip().split('\n'):
            parts = line.split(':')
            if len(parts) >= 2 and parts[1] == interface:
                conn_name = parts[0]
                break
        
        if not conn_name:
            return False, f"No connection found for {interface}"
        
        # Configure DHCP
        subprocess.run(
            ['sudo', 'nmcli', 'con', 'modify', conn_name, 'ipv4.method', 'auto'],
            capture_output=True, timeout=10
        )
        
        # Clear static settings
        subprocess.run(
            ['sudo', 'nmcli', 'con', 'modify', conn_name, 'ipv4.addresses', ''],
            capture_output=True, timeout=10
        )
        subprocess.run(
            ['sudo', 'nmcli', 'con', 'modify', conn_name, 'ipv4.gateway', ''],
            capture_output=True, timeout=10
        )
        
        # Restart connection
        subprocess.run(['sudo', 'nmcli', 'con', 'down', conn_name], 
                      capture_output=True, timeout=10)
        subprocess.run(['sudo', 'nmcli', 'con', 'up', conn_name], 
                      capture_output=True, timeout=10)
        
        return True, "DHCP configured"
    except Exception as e:
        return False, str(e)


# ============================================================================
# LED Management Functions (Raspberry Pi specific)
# ============================================================================

def get_led_paths():
    """Get LED paths based on platform."""
    leds = {}
    
    # Standard Raspberry Pi LED paths
    pwr_paths = ['/sys/class/leds/PWR', '/sys/class/leds/led1']
    act_paths = ['/sys/class/leds/ACT', '/sys/class/leds/led0']
    
    for path in pwr_paths:
        if os.path.exists(path):
            leds['pwr'] = path
            break
    
    for path in act_paths:
        if os.path.exists(path):
            leds['act'] = path
            break
    
    # Ethernet LED paths (Pi 4/5 with bcmgenet only)
    # Pi 3B/3B+ (smsc95xx/lan78xx) don't have software-controllable LEDs
    eth_led_paths = [
        '/sys/class/leds/led2',           # Some Pi 4 variants
        '/sys/class/leds/eth_led0',       # Alternative naming
        '/sys/class/net/eth0/device/leds' # Generic location
    ]
    for path in eth_led_paths:
        if os.path.exists(path):
            leds['eth'] = path
            break
    
    return leds


def is_ethernet_led_controllable():
    """
    Check if Ethernet LEDs can be controlled via software.
    
    Returns tuple: (controllable: bool, reason: str)
    
    Note: Raspberry Pi 3B/3B+ use smsc95xx/lan78xx controllers
    where LEDs are controlled by the PHY chip, not software.
    Pi 4/5 with bcmgenet may have software control.
    """
    # Check for known non-controllable drivers
    driver_path = '/sys/class/net/eth0/device/driver/module/name'
    if os.path.exists(driver_path):
        try:
            with open(driver_path, 'r') as f:
                driver = f.read().strip()
                if driver in ['smsc95xx', 'lan78xx']:
                    return False, f"Driver {driver} (LEDs controlled by PHY)"
        except:
            pass
    
    # Check for ethtool LED control (Pi 4/5)
    try:
        result = subprocess.run(
            ['ethtool', '--show-eee', 'eth0'],
            capture_output=True, text=True, timeout=5
        )
        # If ethtool exists and doesn't error, we might have control
        if result.returncode == 0:
            return True, "ethtool supported"
    except:
        pass
    
    # Check for sysfs LED control
    led_paths = [
        '/sys/class/leds/led2',
        '/sys/class/leds/eth_led0',
    ]
    for path in led_paths:
        if os.path.exists(path):
            return True, f"sysfs control at {path}"
    
    return False, "No software control available"


def get_led_status():
    """Get current LED status."""
    leds = {
        'pwr': {'enabled': True, 'trigger': 'default-on', 'available': False, 'boot_disabled': False},
        'act': {'enabled': True, 'trigger': 'mmc0', 'available': False, 'boot_disabled': False},
        'eth': {'enabled': True, 'trigger': None, 'available': False, 'boot_disabled': False, 'reason': ''}
    }
    
    if not PLATFORM['has_led_control']:
        # Still check Ethernet LED availability even without general LED control
        eth_controllable, eth_reason = is_ethernet_led_controllable()
        leds['eth']['available'] = eth_controllable
        leds['eth']['reason'] = eth_reason
        return leds
    
    led_paths = get_led_paths()
    
    # Get boot config status
    boot_config = get_led_boot_config()
    
    try:
        # Check PWR LED
        if 'pwr' in led_paths:
            leds['pwr']['available'] = True
            leds['pwr']['boot_disabled'] = not boot_config.get('pwr_enabled', True)
            
            pwr_path = f"{led_paths['pwr']}/brightness"
            if os.path.exists(pwr_path):
                with open(pwr_path, 'r') as f:
                    leds['pwr']['enabled'] = int(f.read().strip()) > 0
            
            pwr_trigger = f"{led_paths['pwr']}/trigger"
            if os.path.exists(pwr_trigger):
                with open(pwr_trigger, 'r') as f:
                    content = f.read()
                    match = re.search(r'\[([^\]]+)\]', content)
                    if match:
                        leds['pwr']['trigger'] = match.group(1)
        
        # Check ACT LED
        if 'act' in led_paths:
            leds['act']['available'] = True
            leds['act']['boot_disabled'] = not boot_config.get('act_enabled', True)
            
            act_path = f"{led_paths['act']}/brightness"
            if os.path.exists(act_path):
                with open(act_path, 'r') as f:
                    leds['act']['enabled'] = int(f.read().strip()) > 0
            
            act_trigger = f"{led_paths['act']}/trigger"
            if os.path.exists(act_trigger):
                with open(act_trigger, 'r') as f:
                    content = f.read()
                    match = re.search(r'\[([^\]]+)\]', content)
                    if match:
                        leds['act']['trigger'] = match.group(1)
        
        # Check Ethernet LED
        eth_controllable, eth_reason = is_ethernet_led_controllable()
        leds['eth']['available'] = eth_controllable
        leds['eth']['reason'] = eth_reason
        
        if eth_controllable and 'eth' in led_paths:
            eth_path = f"{led_paths['eth']}/brightness"
            if os.path.exists(eth_path):
                with open(eth_path, 'r') as f:
                    leds['eth']['enabled'] = int(f.read().strip()) > 0
            
            eth_trigger = f"{led_paths['eth']}/trigger"
            if os.path.exists(eth_trigger):
                with open(eth_trigger, 'r') as f:
                    content = f.read()
                    match = re.search(r'\[([^\]]+)\]', content)
                    if match:
                        leds['eth']['trigger'] = match.group(1)
                        
    except Exception as e:
        print(f"Error getting LED status: {e}")
    
    return leds


def set_led_state(led, enabled, trigger=None):
    """Set LED state (immediate effect)."""
    led_paths = get_led_paths()
    
    if led not in led_paths:
        return False, f"LED '{led}' not found"
    
    try:
        led_base = led_paths[led]
        
        # Set trigger to 'none' to disable any automatic behavior
        trigger_path = f'{led_base}/trigger'
        if os.path.exists(trigger_path):
            new_trigger = trigger if trigger else ('default-on' if enabled else 'none')
            subprocess.run(
                ['sudo', 'bash', '-c', f'echo "{new_trigger}" > {trigger_path}'],
                capture_output=True, timeout=5
            )
        
        # Set brightness for immediate effect
        brightness_path = f'{led_base}/brightness'
        if os.path.exists(brightness_path):
            value = '1' if enabled else '0'
            subprocess.run(
                ['sudo', 'bash', '-c', f'echo "{value}" > {brightness_path}'],
                capture_output=True, timeout=5
            )
        
        return True, "LED updated"
    except Exception as e:
        return False, str(e)


def configure_leds_boot(pwr_enabled, act_enabled):
    """
    Configure LEDs in boot config for persistence across reboots.
    
    This ensures LEDs are disabled from the very first moment of boot
    if configured to be off. Uses dtparam overlay parameters.
    
    For Raspberry Pi 3B+/4/5:
    - PWR LED (red): dtparam=pwr_led_trigger, dtparam=pwr_led_activelow
    - ACT LED (green): dtparam=act_led_trigger, dtparam=act_led_activelow
    
    To completely disable a LED at boot:
    - Set trigger to 'none' (no automatic behavior)
    - Set activelow to 'off' (LED stays off when trigger is none)
    """
    if not BOOT_CONFIG_FILE:
        return False, "Boot config not found"
    
    try:
        config_content = ""
        if os.path.exists(BOOT_CONFIG_FILE):
            with open(BOOT_CONFIG_FILE, 'r') as f:
                config_content = f.read()
        
        # Remove existing LED settings (all variations)
        patterns_to_remove = [
            r'\n?# LED Configuration[^\n]*\n?',
            r'\n?# Disable PWR LED[^\n]*\n?',
            r'\n?# Disable ACT LED[^\n]*\n?',
            r'\n?dtparam=pwr_led_trigger=[^\n]*',
            r'\n?dtparam=pwr_led_activelow=[^\n]*',
            r'\n?dtparam=act_led_trigger=[^\n]*',
            r'\n?dtparam=act_led_activelow=[^\n]*',
            r'\n?dtparam=act_led_gpio=[^\n]*',
            r'\n?dtparam=pwr_led_gpio=[^\n]*',
            # Pi 5 specific
            r'\n?dtparam=power_led_trigger=[^\n]*',
            r'\n?dtparam=power_led_activelow=[^\n]*',
            r'\n?dtparam=activity_led_trigger=[^\n]*',
            r'\n?dtparam=activity_led_activelow=[^\n]*',
        ]
        
        for pattern in patterns_to_remove:
            config_content = re.sub(pattern, '', config_content)
        
        # Clean up multiple blank lines
        config_content = re.sub(r'\n{3,}', '\n\n', config_content)
        
        # Build new LED configuration
        led_config_lines = []
        
        # Detect Pi model for correct parameters
        pi_model = PLATFORM.get('model', '')
        is_pi5 = 'Pi 5' in pi_model or 'Raspberry Pi 5' in pi_model
        
        if not pwr_enabled:
            led_config_lines.append("# Disable PWR LED (red) - completely off at boot")
            if is_pi5:
                led_config_lines.append("dtparam=power_led_trigger=none")
                led_config_lines.append("dtparam=power_led_activelow=off")
            else:
                led_config_lines.append("dtparam=pwr_led_trigger=none")
                led_config_lines.append("dtparam=pwr_led_activelow=off")
        
        if not act_enabled:
            led_config_lines.append("# Disable ACT LED (green) - completely off at boot")
            if is_pi5:
                led_config_lines.append("dtparam=activity_led_trigger=none")
                led_config_lines.append("dtparam=activity_led_activelow=off")
            else:
                led_config_lines.append("dtparam=act_led_trigger=none")
                led_config_lines.append("dtparam=act_led_activelow=off")
        
        # Only add LED section if there are changes
        if led_config_lines:
            led_config = "\n\n# === LED Configuration (managed by web interface) ===\n"
            led_config += "\n".join(led_config_lines) + "\n"
            config_content = config_content.rstrip() + led_config
        
        # Write the config file
        with open(BOOT_CONFIG_FILE, 'w') as f:
            f.write(config_content)
        
        return True, "LED boot config updated (reboot required for full effect)"
    except PermissionError:
        return False, "Permission denied. Run with sudo."
    except Exception as e:
        return False, str(e)


def get_led_boot_config():
    """
    Read current LED configuration from boot config.
    Returns dict with current settings.
    """
    config = {
        'pwr_enabled': True,
        'act_enabled': True,
        'source': 'default'
    }
    
    if not BOOT_CONFIG_FILE or not os.path.exists(BOOT_CONFIG_FILE):
        return config
    
    try:
        with open(BOOT_CONFIG_FILE, 'r') as f:
            content = f.read()
        
        # Check for PWR LED disabled
        if re.search(r'dtparam=pwr_led_trigger=none', content) or \
           re.search(r'dtparam=power_led_trigger=none', content):
            config['pwr_enabled'] = False
            config['source'] = 'boot_config'
        
        # Check for ACT LED disabled
        if re.search(r'dtparam=act_led_trigger=none', content) or \
           re.search(r'dtparam=activity_led_trigger=none', content):
            config['act_enabled'] = False
            config['source'] = 'boot_config'
    except Exception as e:
        print(f"Error reading LED boot config: {e}")
    
    return config


# ============================================================================
# GPU Memory Management Functions (Raspberry Pi specific)
# ============================================================================

def get_gpu_mem():
    """Get current GPU memory allocation."""
    gpu_mem = 128  # Default
    try:
        # Try vcgencmd first (most accurate on Pi)
        if PLATFORM['has_vcgencmd']:
            result = subprocess.run(
                ['vcgencmd', 'get_mem', 'gpu'],
                capture_output=True, text=True, timeout=5
            )
            match = re.search(r'gpu=(\d+)M', result.stdout)
            if match:
                return int(match.group(1))
        
        # Fallback: read from config.txt
        if BOOT_CONFIG_FILE and os.path.exists(BOOT_CONFIG_FILE):
            with open(BOOT_CONFIG_FILE, 'r') as f:
                for line in f:
                    match = re.match(r'^gpu_mem=(\d+)', line.strip())
                    if match:
                        gpu_mem = int(match.group(1))
                        break
    except Exception as e:
        print(f"Error getting GPU mem: {e}")
    return gpu_mem


def set_gpu_mem(mem_mb):
    """Set GPU memory allocation in boot config."""
    if not BOOT_CONFIG_FILE:
        return False, "Boot config not found"
    
    try:
        # Validate value (Pi 3B+ valid range: 16-944, recommended 128-256)
        mem_mb = max(16, min(512, int(mem_mb)))
        
        config_content = ""
        if os.path.exists(BOOT_CONFIG_FILE):
            with open(BOOT_CONFIG_FILE, 'r') as f:
                config_content = f.read()
        
        # Remove existing gpu_mem settings
        config_content = re.sub(r'\n?gpu_mem=\d+', '', config_content)
        config_content = re.sub(r'\n?gpu_mem_\d+=\d+', '', config_content)
        
        # Add new setting
        config_content = config_content.rstrip() + f"\n\n# GPU Memory\ngpu_mem={mem_mb}\n"
        
        with open(BOOT_CONFIG_FILE, 'w') as f:
            f.write(config_content)
        
        return True, f"GPU memory set to {mem_mb}MB (reboot required)"
    except Exception as e:
        return False, str(e)


# ============================================================================
# Power Management Functions (Energy Saving - Raspberry Pi specific)
# ============================================================================

def get_power_status():
    """Get current power state of all components."""
    status = {
        'bluetooth': {'enabled': None, 'boot_config': None, 'available': False},
        'hdmi': {'enabled': None, 'boot_config': None, 'available': True},
        'audio': {'enabled': None, 'boot_config': None, 'available': True},
        'cpu_freq': {'current': None, 'min': 600, 'max': 1500, 'available': True},
        'estimated_savings_ma': 0
    }
    
    try:
        # Check Bluetooth
        bt_result = subprocess.run(
            ['systemctl', 'is-enabled', 'bluetooth'],
            capture_output=True, text=True, timeout=5
        )
        if bt_result.returncode == 0:
            status['bluetooth']['available'] = True
            status['bluetooth']['enabled'] = bt_result.stdout.strip() == 'enabled'
        
        # Check HDMI (from boot config)
        if BOOT_CONFIG_FILE and os.path.exists(BOOT_CONFIG_FILE):
            with open(BOOT_CONFIG_FILE, 'r') as f:
                content = f.read()
                # HDMI0 is always on by default unless explicitly disabled
                status['hdmi']['boot_config'] = not re.search(r'hdmi_blanking\s*=\s*2', content)
                # Audio disabled if dtparam=audio=off
                status['audio']['boot_config'] = not re.search(r'dtparam\s*=\s*audio\s*=\s*off', content)
                # Bluetooth disabled if dtoverlay=disable-bt
                status['bluetooth']['boot_config'] = not re.search(r'dtoverlay\s*=\s*disable-bt', content)
        
        # Get CPU frequency (for Pi 3B+ and 4)
        cpu_freq_path = '/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq'
        if os.path.exists(cpu_freq_path):
            try:
                with open(cpu_freq_path, 'r') as f:
                    freq_khz = int(f.read().strip())
                    status['cpu_freq']['current'] = freq_khz // 1000  # Convert to MHz
            except:
                pass
        
        # Calculate estimated energy savings (rough estimates in mA)
        savings = 0
        if status['bluetooth']['boot_config'] is False:
            savings += 20  # ~20 mA without BT
        if status['hdmi']['boot_config'] is False:
            savings += 40  # ~40 mA without HDMI
        if status['audio']['boot_config'] is False:
            savings += 10  # ~10 mA without audio
        
        # WiFi savings
        boot_config = get_boot_power_config()
        if boot_config.get('wifi_enabled') is False:
            savings += 40  # ~40 mA without WiFi
        
        # LED savings  
        if boot_config.get('pwr_led_enabled') is False:
            savings += 5  # ~5 mA for PWR LED
        if boot_config.get('act_led_enabled') is False:
            savings += 3  # ~3 mA average for ACT LED (blinks)
        
        # CPU underclocking savings (very approximate)
        if status['cpu_freq']['current'] and status['cpu_freq']['current'] < 1200:
            underclocking_percent = (1200 - status['cpu_freq']['current']) / 1200
            savings += int(100 * underclocking_percent)  # Up to ~100 mA saved
        
        status['estimated_savings_ma'] = savings
        
    except Exception as e:
        print(f"Error getting power status: {e}")
    
    return status


# =============================================================================
# Service Management Functions
# =============================================================================

# Services that can be safely disabled for power savings
OPTIONAL_SERVICES = {
    'modemmanager': {
        'unit': 'ModemManager.service',
        'description': 'Gestion modems 3G/4G',
        'savings_ma': 15,
        'safe_to_disable': True
    },
    'avahi': {
        'unit': 'avahi-daemon.service', 
        'description': 'mDNS/Bonjour discovery',
        'savings_ma': 5,
        'safe_to_disable': True,
        'warning': 'Peut affecter la découverte ONVIF'
    },
    'cloudinit': {
        'units': [
            'cloud-init-local.service',
            'cloud-init-network.service', 
            'cloud-init-main.service',
            'cloud-config.service',
            'cloud-final.service'
        ],
        'description': 'Provisioning cloud',
        'savings_ma': 0,  # RAM only, no direct power
        'safe_to_disable': True
    },
    'serial': {
        'unit': 'serial-getty@ttyAMA0.service',
        'description': 'Console série',
        'savings_ma': 2,
        'safe_to_disable': True
    },
    'tty1': {
        'unit': 'getty@tty1.service',
        'description': 'Console TTY1',
        'savings_ma': 2,
        'safe_to_disable': True
    },
    'udisks2': {
        'unit': 'udisks2.service',
        'description': 'Automontage USB',
        'savings_ma': 5,
        'safe_to_disable': True,
        'warning': 'Désactive l\'automontage des clés USB'
    }
}


def get_optional_service_status(service_key):
    """Get the enabled status of an optional service."""
    if service_key not in OPTIONAL_SERVICES:
        return None
    
    service_info = OPTIONAL_SERVICES[service_key]
    
    try:
        # Handle services with multiple units (like cloud-init)
        if 'units' in service_info:
            # Check if ANY of the units is enabled
            for unit in service_info['units']:
                result = subprocess.run(
                    ['systemctl', 'is-enabled', unit],
                    capture_output=True, text=True, timeout=5
                )
                if result.stdout.strip() == 'enabled':
                    return True
            return False
        else:
            result = subprocess.run(
                ['systemctl', 'is-enabled', service_info['unit']],
                capture_output=True, text=True, timeout=5
            )
            return result.stdout.strip() == 'enabled'
    except Exception as e:
        print(f"Error checking service {service_key}: {e}")
        return None


def get_all_services_status():
    """Get status of all optional services."""
    status = {}
    for key in OPTIONAL_SERVICES:
        enabled = get_optional_service_status(key)
        status[key] = {
            'enabled': enabled,
            'description': OPTIONAL_SERVICES[key]['description'],
            'savings_ma': OPTIONAL_SERVICES[key]['savings_ma'],
            'warning': OPTIONAL_SERVICES[key].get('warning')
        }
    return status


def set_service_state(service_key, enabled):
    """Enable or disable a service."""
    if service_key not in OPTIONAL_SERVICES:
        return False, f"Unknown service: {service_key}"
    
    service_info = OPTIONAL_SERVICES[service_key]
    action = 'enable' if enabled else 'disable'
    
    try:
        # Handle services with multiple units
        if 'units' in service_info:
            for unit in service_info['units']:
                result = subprocess.run(
                    ['sudo', 'systemctl', action, unit],
                    capture_output=True, text=True, timeout=10
                )
                if result.returncode != 0:
                    return False, f"Failed to {action} {unit}: {result.stderr}"
                
                # Also stop/start if disabling/enabling
                if not enabled:
                    subprocess.run(['sudo', 'systemctl', 'stop', unit], 
                                   capture_output=True, timeout=10)
            return True, f"Cloud-init services {action}d"
        else:
            unit = service_info['unit']
            result = subprocess.run(
                ['sudo', 'systemctl', action, unit],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                # Also stop if disabling
                if not enabled:
                    subprocess.run(['sudo', 'systemctl', 'stop', unit],
                                   capture_output=True, timeout=10)
                return True, f"Service {unit} {action}d"
            else:
                return False, result.stderr or f"Failed to {action} {unit}"
                
    except Exception as e:
        return False, str(e)


def set_bluetooth_state(enabled):
    """Enable or disable Bluetooth."""
    try:
        action = 'enable' if enabled else 'disable'
        result = subprocess.run(
            ['sudo', 'systemctl', action, 'bluetooth'],
            capture_output=True, text=True, timeout=5
        )
        
        if result.returncode == 0:
            return True, f"Bluetooth {action}d"
        else:
            return False, result.stderr or f"Failed to {action} Bluetooth"
    except Exception as e:
        return False, str(e)


def configure_power_boot(bluetooth_enabled, hdmi_enabled, audio_enabled, wifi_enabled=True, pwr_led_enabled=True, act_led_enabled=True, camera_led_csi_enabled=True):
    """
    Configure power settings in boot config for persistence across reboots.
    
    Parameters:
    - bluetooth_enabled: True to enable BT, False to disable
    - hdmi_enabled: True to enable HDMI, False to disable  
    - audio_enabled: True to enable Audio, False to disable
    - wifi_enabled: True to enable WiFi, False to disable
    - pwr_led_enabled: True to enable PWR LED, False to disable
    - act_led_enabled: True to enable ACT LED, False to disable
    - camera_led_csi_enabled: True to enable CSI camera LED, False to disable
    """
    if not BOOT_CONFIG_FILE:
        return False, "Boot config not found"
    
    try:
        config_content = ""
        if os.path.exists(BOOT_CONFIG_FILE):
            with open(BOOT_CONFIG_FILE, 'r') as f:
                config_content = f.read()
        
        # Remove existing power management settings
        patterns_to_remove = [
            r'\n?# Power Management[^\n]*\n?',
            r'\n?# === Power Management[^\n]*\n?',
            r'\n?dtoverlay\s*=\s*disable-bt[^\n]*',
            r'\n?dtoverlay\s*=\s*disable-wifi[^\n]*',
            r'\n?hdmi_blanking\s*=\s*\d+[^\n]*',
            r'\n?dtparam\s*=\s*audio\s*=\s*off[^\n]*',
            r'\n?dtparam\s*=\s*audio\s*=\s*on[^\n]*',
            # LED settings
            r'\n?# === LED Configuration[^\n]*\n?',
            r'\n?# Disable PWR LED[^\n]*\n?',
            r'\n?# Disable ACT LED[^\n]*\n?',
            r'\n?# Disable Camera LED[^\n]*\n?',
            r'\n?dtparam=pwr_led_trigger=[^\n]*',
            r'\n?dtparam=pwr_led_activelow=[^\n]*',
            r'\n?dtparam=act_led_trigger=[^\n]*',
            r'\n?dtparam=act_led_activelow=[^\n]*',
            r'\n?dtparam=power_led_trigger=[^\n]*',
            r'\n?dtparam=power_led_activelow=[^\n]*',
            r'\n?dtparam=activity_led_trigger=[^\n]*',
            r'\n?dtparam=activity_led_activelow=[^\n]*',
            r'\n?disable_camera_led=[^\n]*',
        ]
        
        for pattern in patterns_to_remove:
            config_content = re.sub(pattern, '', config_content)
        
        # Clean up multiple blank lines
        config_content = re.sub(r'\n{3,}', '\n\n', config_content)
        
        # Build new power configuration
        power_config_lines = []
        power_config_lines.append("# === Power Management (managed by web interface) ===")
        
        if not bluetooth_enabled:
            power_config_lines.append("dtoverlay=disable-bt")
        
        if not wifi_enabled:
            power_config_lines.append("dtoverlay=disable-wifi")
        
        if not hdmi_enabled:
            power_config_lines.append("hdmi_blanking=2")
        
        if not audio_enabled:
            power_config_lines.append("dtparam=audio=off")
        
        # Detect Pi model for correct LED parameters
        pi_model = PLATFORM.get('model', '')
        is_pi5 = 'Pi 5' in pi_model or 'Raspberry Pi 5' in pi_model
        
        if not pwr_led_enabled:
            power_config_lines.append("# Disable PWR LED (red)")
            if is_pi5:
                power_config_lines.append("dtparam=power_led_trigger=none")
                power_config_lines.append("dtparam=power_led_activelow=off")
            else:
                power_config_lines.append("dtparam=pwr_led_trigger=none")
                power_config_lines.append("dtparam=pwr_led_activelow=off")
        
        if not act_led_enabled:
            power_config_lines.append("# Disable ACT LED (green)")
            if is_pi5:
                power_config_lines.append("dtparam=activity_led_trigger=none")
                power_config_lines.append("dtparam=activity_led_activelow=off")
            else:
                power_config_lines.append("dtparam=act_led_trigger=none")
                power_config_lines.append("dtparam=act_led_activelow=off")
        
        if not camera_led_csi_enabled:
            power_config_lines.append("# Disable Camera LED (CSI module)")
            power_config_lines.append("disable_camera_led=1")
        
        # Only add power section if there are changes
        if len(power_config_lines) > 1:
            power_config = "\n" + "\n".join(power_config_lines) + "\n"
            config_content = config_content.rstrip() + power_config
        
        # Write the config file
        with open(BOOT_CONFIG_FILE, 'w') as f:
            f.write(config_content)
        
        return True, "Power boot config updated (reboot required)"
    except PermissionError:
        return False, "Permission denied. Run with sudo."
    except Exception as e:
        return False, str(e)


def set_cpu_frequency(freq_mhz):
    """Set CPU frequency (requires cpufreq-set or raspi-config)."""
    try:
        freq_mhz = max(600, min(1500, int(freq_mhz)))
        
        # Try using cpufreq-set (requires cpufrequtils package)
        result = subprocess.run(
            ['sudo', 'cpufreq-set', '-f', f'{freq_mhz}MHz'],
            capture_output=True, text=True, timeout=5
        )
        
        if result.returncode == 0:
            return True, f"CPU frequency set to {freq_mhz}MHz"
        
        # Fallback: try via sysfs directly
        # This requires proper permissions and may not work on all systems
        return False, "cpufreq-set not available. Manual CPU frequency scaling not supported."
    except Exception as e:
        return False, str(e)


def get_boot_power_config():
    """Read current power configuration from boot config."""
    config = {
        'bluetooth_enabled': True,
        'wifi_enabled': True,
        'hdmi_enabled': True,
        'audio_enabled': True,
        'pwr_led_enabled': True,
        'act_led_enabled': True,
        'camera_led_csi_enabled': True,
        'source': 'default'
    }
    
    if not BOOT_CONFIG_FILE or not os.path.exists(BOOT_CONFIG_FILE):
        return config
    
    try:
        with open(BOOT_CONFIG_FILE, 'r') as f:
            content = f.read()
        
        # Check for disabled components
        if re.search(r'dtoverlay\s*=\s*disable-bt', content):
            config['bluetooth_enabled'] = False
            config['source'] = 'boot_config'
        
        if re.search(r'dtoverlay\s*=\s*disable-wifi', content):
            config['wifi_enabled'] = False
            config['source'] = 'boot_config'
        
        if re.search(r'hdmi_blanking\s*=\s*2', content):
            config['hdmi_enabled'] = False
            config['source'] = 'boot_config'
        
        if re.search(r'dtparam\s*=\s*audio\s*=\s*off', content):
            config['audio_enabled'] = False
            config['source'] = 'boot_config'
        
        # Check for PWR LED disabled
        if re.search(r'dtparam=pwr_led_trigger=none', content) or \
           re.search(r'dtparam=power_led_trigger=none', content):
            config['pwr_led_enabled'] = False
            config['source'] = 'boot_config'
        
        # Check for ACT LED disabled
        if re.search(r'dtparam=act_led_trigger=none', content) or \
           re.search(r'dtparam=activity_led_trigger=none', content):
            config['act_led_enabled'] = False
            config['source'] = 'boot_config'
        
        # Check for Camera LED (CSI) disabled
        if re.search(r'disable_camera_led\s*=\s*1', content):
            config['camera_led_csi_enabled'] = False
            config['source'] = 'boot_config'
            
    except Exception as e:
        print(f"Error reading power boot config: {e}")
    
    return config


# ============================================================================
# Configuration Management
# ============================================================================

def load_config():
    """Load configuration from file or return defaults."""
    config = DEFAULT_CONFIG.copy()
    
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        key = key.strip()
                        value = value.strip().strip('"').strip("'")
                        if key in config:
                            config[key] = value
        except Exception as e:
            print(f"Error loading config: {e}")
    
    return config


def save_config(config):
    """Save configuration to file."""
    config_dir = os.path.dirname(CONFIG_FILE)
    os.makedirs(config_dir, exist_ok=True)
    
    with open(CONFIG_FILE, 'w') as f:
        f.write("# RTSP Recorder Configuration\n")
        f.write("# Generated by web-manager\n\n")
        
        categories = {}
        for key, value in config.items():
            if key in CONFIG_METADATA:
                cat = CONFIG_METADATA[key].get('category', 'other')
                if cat not in categories:
                    categories[cat] = []
                categories[cat].append((key, value))
        
        category_names = {
            'rtsp': 'RTSP Settings',
            'video': 'Video Settings',
            'recording': 'Recording Settings',
            'audio': 'Audio Settings',
            'advanced': 'Advanced Settings',
            'meeting': 'Meeting API Settings',
            'network': 'Network Settings'
        }
        
        for cat in ['rtsp', 'video', 'recording', 'audio', 'network', 'meeting', 'advanced']:
            if cat in categories:
                f.write(f"# {category_names.get(cat, cat)}\n")
                for key, value in categories[cat]:
                    f.write(f'{key}="{value}"\n')
                f.write("\n")


def get_service_status():
    """Get the status of the RTSP recorder service."""
    try:
        result = subprocess.run(
            ['systemctl', 'is-active', SERVICE_NAME],
            capture_output=True, text=True, timeout=5
        )
        status = result.stdout.strip()
        return status if status else 'unknown'
    except Exception:
        return 'unknown'


def control_service(action):
    """Control the RTSP recorder service."""
    try:
        if action in ['start', 'stop', 'restart', 'enable', 'disable']:
            result = subprocess.run(
                ['sudo', 'systemctl', action, SERVICE_NAME],
                capture_output=True, text=True, timeout=30
            )
            return result.returncode == 0, result.stderr or result.stdout
    except Exception as e:
        return False, str(e)
    return False, "Invalid action"


def get_system_info():
    """Get system information for display."""
    info = {
        'platform': PLATFORM
    }
    
    # Get hostname
    try:
        info['hostname'] = subprocess.run(
            ['hostname'], capture_output=True, text=True, timeout=5
        ).stdout.strip()
    except:
        info['hostname'] = 'unknown'
    
    # Get IP addresses
    try:
        result = subprocess.run(
            ['hostname', '-I'], capture_output=True, text=True, timeout=5
        )
        info['ip_addresses'] = result.stdout.strip().split()
    except:
        info['ip_addresses'] = []
    
    # Get OS info
    try:
        if os.path.exists('/etc/os-release'):
            with open('/etc/os-release', 'r') as f:
                for line in f:
                    if line.startswith('PRETTY_NAME='):
                        info['os_name'] = line.split('=')[1].strip().strip('"')
                        break
    except:
        info['os_name'] = 'Unknown OS'
    
    # Get uptime
    try:
        result = subprocess.run(
            ['uptime', '-p'], capture_output=True, text=True, timeout=5
        )
        uptime_raw = result.stdout.strip().replace('up ', '')
        # Translate to French
        uptime_fr = uptime_raw.replace('days', 'j').replace('day', 'j') \
                             .replace('hours', 'h').replace('hour', 'h') \
                             .replace('minutes', 'm').replace('minute', 'm') \
                             .replace(',', '')
        info['uptime'] = uptime_fr
    except:
        info['uptime'] = 'N/A'
    
    # Get CPU usage
    try:
        result = subprocess.run(
            ['grep', '-c', '^processor', '/proc/cpuinfo'],
            capture_output=True, text=True, timeout=5
        )
        info['cpu_cores'] = int(result.stdout.strip())
        
        # Get load average
        with open('/proc/loadavg', 'r') as f:
            load = f.read().split()
            info['load_1m'] = float(load[0])
            info['load_5m'] = float(load[1])
            info['load_15m'] = float(load[2])
            # Calculate CPU usage percentage based on load and cores
            info['cpu_percent'] = min(100, round((info['load_1m'] / info['cpu_cores']) * 100, 1))
    except:
        info['cpu_cores'] = 1
        info['cpu_percent'] = 0
        info['load_1m'] = 0
    
    # Get RAM usage
    try:
        with open('/proc/meminfo', 'r') as f:
            meminfo = {}
            for line in f:
                parts = line.split(':')
                if len(parts) == 2:
                    key = parts[0].strip()
                    value = int(parts[1].strip().split()[0])  # Value in kB
                    meminfo[key] = value
            
            total_kb = meminfo.get('MemTotal', 0)
            avail_kb = meminfo.get('MemAvailable', meminfo.get('MemFree', 0))
            used_kb = total_kb - avail_kb
            
            info['ram_total_mb'] = round(total_kb / 1024)
            info['ram_used_mb'] = round(used_kb / 1024)
            info['ram_avail_mb'] = round(avail_kb / 1024)
            info['ram_percent'] = round((used_kb / total_kb) * 100, 1) if total_kb > 0 else 0
    except:
        info['ram_total_mb'] = 0
        info['ram_used_mb'] = 0
        info['ram_percent'] = 0
    
    # Get CPU temperature (Raspberry Pi specific)
    try:
        if os.path.exists('/sys/class/thermal/thermal_zone0/temp'):
            with open('/sys/class/thermal/thermal_zone0/temp', 'r') as f:
                temp_millideg = int(f.read().strip())
                info['cpu_temp'] = round(temp_millideg / 1000, 1)
        else:
            # Try vcgencmd on Raspberry Pi
            result = subprocess.run(
                ['vcgencmd', 'measure_temp'], capture_output=True, text=True, timeout=5
            )
            # Output: temp=45.0'C
            if 'temp=' in result.stdout:
                temp_str = result.stdout.split('=')[1].split("'")[0]
                info['cpu_temp'] = float(temp_str)
    except:
        info['cpu_temp'] = None
    
    # Get disk usage for recording dir
    config = load_config()
    record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
    try:
        if os.path.exists(record_dir):
            result = subprocess.run(
                ['df', '-h', record_dir], capture_output=True, text=True, timeout=5
            )
            lines = result.stdout.strip().split('\n')
            if len(lines) > 1:
                parts = lines[1].split()
                if len(parts) >= 4:
                    info['disk_total'] = parts[1]
                    info['disk_used'] = parts[2]
                    info['disk_avail'] = parts[3]
                    info['disk_percent'] = parts[4] if len(parts) > 4 else 'N/A'
                    # Extract numeric percent
                    try:
                        info['disk_percent_num'] = int(info['disk_percent'].replace('%', ''))
                    except:
                        info['disk_percent_num'] = 0
    except:
        pass
    
    # Get recording files count and size
    try:
        if os.path.exists(record_dir):
            files = list(Path(record_dir).glob('*.ts'))
            info['recording_count'] = len(files)
            total_size = sum(f.stat().st_size for f in files)
            info['recording_size_mb'] = round(total_size / (1024 * 1024), 1)
    except:
        info['recording_count'] = 0
        info['recording_size_mb'] = 0
    
    return info


def get_recent_logs(lines=50, source='all'):
    """Get recent log entries from multiple sources."""
    logs = []
    config = load_config()
    log_dir = config.get('LOG_DIR', '/var/log/rpi-cam')
    log_file = os.path.join(log_dir, 'rpi_av_rtsp_recorder.log')
    
    # Get logs from file
    if source in ('all', 'file'):
        try:
            if os.path.exists(log_file):
                result = subprocess.run(
                    ['tail', '-n', str(lines), log_file],
                    capture_output=True, text=True, timeout=5
                )
                if result.stdout.strip():
                    logs.append(f"=== Fichier log ({log_file}) ===\n{result.stdout}")
        except Exception as e:
            logs.append(f"=== Fichier log (erreur) ===\n{str(e)}")
    
    # Get logs from journald (systemd service)
    if source in ('all', 'journald'):
        try:
            result = subprocess.run(
                ['journalctl', '-u', SERVICE_NAME, '-n', str(lines), '--no-pager', '-o', 'short-iso'],
                capture_output=True, text=True, timeout=10
            )
            if result.stdout.strip():
                logs.append(f"=== Journald ({SERVICE_NAME}) ===\n{result.stdout}")
        except Exception as e:
            logs.append(f"=== Journald (erreur) ===\n{str(e)}")
    
    # Get GStreamer logs if available
    if source in ('all', 'gstreamer'):
        gst_log = os.path.join(log_dir, 'gstreamer.log')
        try:
            if os.path.exists(gst_log):
                result = subprocess.run(
                    ['tail', '-n', str(lines // 2), gst_log],
                    capture_output=True, text=True, timeout=5
                )
                if result.stdout.strip():
                    logs.append(f"=== GStreamer log ===\n{result.stdout}")
        except:
            pass
    
    return '\n\n'.join(logs) if logs else "Aucun log disponible"


def stream_logs():
    """Generator for streaming logs in real-time via SSE."""
    config = load_config()
    log_dir = config.get('LOG_DIR', '/var/log/rpi-cam')
    log_file = os.path.join(log_dir, 'rpi_av_rtsp_recorder.log')
    
    # Use journalctl -f for real-time logs from the service
    try:
        process = subprocess.Popen(
            ['journalctl', '-u', SERVICE_NAME, '-f', '-n', '20', '--no-pager', '-o', 'short-iso'],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1
        )
        
        while True:
            line = process.stdout.readline()
            if line:
                # Format as SSE
                yield f"data: {json.dumps({'log': line.strip(), 'source': 'journald'})}\n\n"
            else:
                # Small sleep to avoid busy loop
                time.sleep(0.1)
                # Send heartbeat to keep connection alive
                yield f": heartbeat\n\n"
    except Exception as e:
        yield f"data: {json.dumps({'error': str(e)})}\n\n"
    finally:
        if 'process' in locals():
            process.terminate()


def get_diagnostic_info():
    """Get diagnostic information for troubleshooting."""
    diag = {
        'service': {},
        'gstreamer': {},
        'camera': {},
        'audio': {},
        'network': {},
        'errors': []
    }
    
    # Check service status
    try:
        result = subprocess.run(
            ['systemctl', 'is-active', SERVICE_NAME],
            capture_output=True, text=True, timeout=5
        )
        diag['service']['status'] = result.stdout.strip()
        diag['service']['active'] = result.returncode == 0
    except Exception as e:
        diag['errors'].append(f"Service check: {e}")
    
    # Check if script exists
    diag['service']['script_exists'] = os.path.exists(SCRIPT_PATH)
    diag['service']['script_path'] = SCRIPT_PATH
    
    # Check GStreamer installation
    try:
        result = subprocess.run(
            ['gst-launch-1.0', '--version'],
            capture_output=True, text=True, timeout=5
        )
        diag['gstreamer']['installed'] = result.returncode == 0
        if result.returncode == 0:
            diag['gstreamer']['version'] = result.stdout.split('\n')[0]
    except FileNotFoundError:
        diag['gstreamer']['installed'] = False
        diag['errors'].append("GStreamer non installé (gst-launch-1.0 introuvable)")
    except Exception as e:
        diag['errors'].append(f"GStreamer check: {e}")
    
    # Check RTSP server plugin
    try:
        result = subprocess.run(
            ['gst-inspect-1.0', 'rtspclientsink'],
            capture_output=True, text=True, timeout=5
        )
        diag['gstreamer']['rtsp_plugin'] = result.returncode == 0
        if result.returncode != 0:
            diag['errors'].append("Plugin RTSP non trouvé (gst-rtsp-server)")
    except Exception as e:
        diag['gstreamer']['rtsp_plugin'] = False
    
    # Check camera devices
    try:
        result = subprocess.run(
            ['v4l2-ctl', '--list-devices'],
            capture_output=True, text=True, timeout=10
        )
        diag['camera']['v4l2_output'] = result.stdout if result.returncode == 0 else result.stderr
        diag['camera']['devices_found'] = '/dev/video' in result.stdout
    except FileNotFoundError:
        diag['camera']['v4l2_output'] = "v4l2-ctl non installé"
        diag['errors'].append("v4l2-utils non installé")
    except Exception as e:
        diag['errors'].append(f"Camera check: {e}")
    
    # Check libcamera
    if PLATFORM['has_libcamera']:
        try:
            result = subprocess.run(
                ['libcamera-hello', '--list-cameras'],
                capture_output=True, text=True, timeout=10
            )
            diag['camera']['libcamera_output'] = result.stdout + result.stderr
            diag['camera']['csi_detected'] = 'Available cameras' in result.stdout
        except Exception as e:
            diag['camera']['libcamera_output'] = str(e)
    
    # Check audio devices
    try:
        result = subprocess.run(
            ['arecord', '-l'],
            capture_output=True, text=True, timeout=10
        )
        diag['audio']['arecord_output'] = result.stdout if result.returncode == 0 else result.stderr
        diag['audio']['devices_found'] = 'card' in result.stdout.lower()
    except FileNotFoundError:
        diag['audio']['arecord_output'] = "alsa-utils non installé"
    except Exception as e:
        diag['errors'].append(f"Audio check: {e}")
    
    # Check network/port availability
    config = load_config()
    rtsp_port = config.get('RTSP_PORT', '8554')
    try:
        result = subprocess.run(
            ['ss', '-tuln'],
            capture_output=True, text=True, timeout=5
        )
        diag['network']['listening_ports'] = result.stdout
        diag['network']['rtsp_port_in_use'] = f":{rtsp_port}" in result.stdout
    except Exception as e:
        diag['errors'].append(f"Network check: {e}")
    
    return diag


# ============================================================================
# Camera Control Functions
# ============================================================================

def get_camera_controls(device='/dev/video0'):
    """Get available camera controls and their current values."""
    controls = {}
    try:
        result = subprocess.run(
            ['v4l2-ctl', '-d', device, '--list-ctrls-menus'],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            for line in result.stdout.split('\n'):
                # Parse control lines like:
                # focus_automatic_continuous 0x009a090c (bool)   : default=0 value=1
                match = re.match(r'\s*(\w+)\s+0x[0-9a-f]+\s+\((\w+)\)\s*:\s*(.*)', line)
                if match:
                    name = match.group(1)
                    ctrl_type = match.group(2)
                    attrs = match.group(3)
                    
                    control = {'type': ctrl_type, 'name': name}
                    
                    # Parse attributes
                    for attr in attrs.split():
                        if '=' in attr:
                            k, v = attr.split('=', 1)
                            control[k] = v
                    
                    controls[name] = control
    except Exception as e:
        print(f"Error getting camera controls: {e}")
    return controls


def set_camera_control(device, control, value):
    """Set a camera control value."""
    try:
        result = subprocess.run(
            ['v4l2-ctl', '-d', device, '--set-ctrl', f'{control}={value}'],
            capture_output=True, text=True, timeout=5
        )
        return result.returncode == 0, result.stderr or result.stdout or 'OK'
    except Exception as e:
        return False, str(e)


def get_camera_autofocus_status(device='/dev/video0'):
    """Get autofocus status for a camera."""
    status = {
        'autofocus_available': False,
        'autofocus_enabled': False,
        'focus_absolute_available': False,
        'focus_absolute': 0,
        'focus_min': 0,
        'focus_max': 255
    }
    
    controls = get_camera_controls(device)
    
    # Check for autofocus control
    if 'focus_automatic_continuous' in controls:
        status['autofocus_available'] = True
        status['autofocus_enabled'] = controls['focus_automatic_continuous'].get('value', '0') == '1'
    elif 'focus_auto' in controls:
        status['autofocus_available'] = True
        status['autofocus_enabled'] = controls['focus_auto'].get('value', '0') == '1'
    
    # Check for manual focus control
    if 'focus_absolute' in controls:
        status['focus_absolute_available'] = True
        status['focus_absolute'] = int(controls['focus_absolute'].get('value', 0))
        status['focus_min'] = int(controls['focus_absolute'].get('min', 0))
        status['focus_max'] = int(controls['focus_absolute'].get('max', 255))
    
    return status


def set_camera_autofocus(device, enabled, persist=False):
    """Enable or disable autofocus.
    
    Args:
        device: Camera device path
        enabled: True to enable autofocus
        persist: If True, save the setting to config.env
    """
    controls = get_camera_controls(device)
    success = False
    message = 'Autofocus control not available'
    
    # Try different autofocus control names
    if 'focus_automatic_continuous' in controls:
        success, message = set_camera_control(device, 'focus_automatic_continuous', 1 if enabled else 0)
    elif 'focus_auto' in controls:
        success, message = set_camera_control(device, 'focus_auto', 1 if enabled else 0)
    
    # Save to config if requested and successful
    if success and persist:
        try:
            config = load_config()
            config['CAMERA_AUTOFOCUS'] = 'yes' if enabled else 'no'
            save_config(config)
        except Exception as e:
            print(f"Error saving autofocus config: {e}")
    
    return success, message


def set_camera_focus(device, value):
    """Set manual focus value."""
    return set_camera_control(device, 'focus_absolute', int(value))


def get_camera_formats(device='/dev/video0'):
    """Get available video formats and resolutions for a camera.
    
    Returns a list of format objects with:
    - format: pixel format (e.g., 'MJPG', 'YUYV')
    - resolutions: list of {width, height, framerates}
    """
    formats = []
    
    try:
        # Get list of formats
        result = subprocess.run(
            ['v4l2-ctl', '-d', device, '--list-formats-ext'],
            capture_output=True, text=True, timeout=10
        )
        
        if result.returncode != 0:
            return formats
        
        current_format = None
        current_resolution = None
        
        for line in result.stdout.split('\n'):
            # Parse format line: [0]: 'MJPG' (Motion-JPEG, compressed)
            format_match = re.match(r"\s*\[\d+\]:\s*'(\w+)'", line)
            if format_match:
                current_format = {
                    'format': format_match.group(1),
                    'resolutions': []
                }
                formats.append(current_format)
                current_resolution = None
                continue
            
            # Parse size line: Size: Discrete 1280x960
            size_match = re.match(r'\s*Size:\s*\w+\s*(\d+)x(\d+)', line)
            if size_match and current_format:
                current_resolution = {
                    'width': int(size_match.group(1)),
                    'height': int(size_match.group(2)),
                    'framerates': []
                }
                current_format['resolutions'].append(current_resolution)
                continue
            
            # Parse framerate line: Interval: Discrete 0.033s (30.000 fps)
            fps_match = re.match(r'\s*Interval:.*\((\d+(?:\.\d+)?)\s*fps\)', line)
            if fps_match and current_resolution:
                fps = float(fps_match.group(1))
                if fps not in current_resolution['framerates']:
                    current_resolution['framerates'].append(fps)
        
        # Sort resolutions by megapixels (descending) and framerates
        for fmt in formats:
            fmt['resolutions'].sort(key=lambda r: r['width'] * r['height'], reverse=True)
            for res in fmt['resolutions']:
                res['framerates'].sort(reverse=True)
        
    except Exception as e:
        print(f"Error getting camera formats: {e}")
    
    return formats


def apply_camera_autofocus_from_config(device='/dev/video0'):
    """Apply autofocus setting from config at startup."""
    try:
        config = load_config()
        autofocus_setting = config.get('CAMERA_AUTOFOCUS', 'yes')  # Default to yes (enabled)
        
        if autofocus_setting == 'yes':
            set_camera_autofocus(device, True, persist=False)
        elif autofocus_setting == 'no':
            set_camera_autofocus(device, False, persist=False)
        # 'auto' means don't change the camera's current setting
        
    except Exception as e:
        print(f"Error applying autofocus from config: {e}")


def trigger_one_shot_focus(device='/dev/video0'):
    """Trigger one-shot autofocus (focus once then stay in manual mode).
    
    This enables autofocus briefly to let the camera focus, then disables it.
    """
    try:
        # Enable autofocus
        success, msg = set_camera_autofocus(device, True, persist=False)
        if not success:
            return False, f"Failed to enable autofocus: {msg}"
        
        # Wait for focus to settle (typical cameras take 500-2000ms)
        time.sleep(1.5)
        
        # Disable autofocus (lock the focus)
        success, msg = set_camera_autofocus(device, False, persist=False)
        if not success:
            return False, f"Failed to lock focus: {msg}"
        
        return True, "Focus triggered and locked"
    except Exception as e:
        return False, str(e)


def get_all_camera_controls(device='/dev/video0'):
    """Get ALL available camera controls with extended info for dynamic UI.
    
    Returns controls grouped by category for better UI organization.
    """
    controls = {}
    categories = {
        'focus': ['focus', 'zoom'],
        'exposure': ['exposure', 'gain', 'brightness', 'contrast', 'gamma', 'backlight'],
        'white_balance': ['white_balance', 'temperature'],
        'color': ['saturation', 'hue', 'sharpness'],
        'power_line': ['power_line', 'frequency'],
        'other': []  # Catch-all
    }
    
    try:
        result = subprocess.run(
            ['v4l2-ctl', '-d', device, '--list-ctrls-menus'],
            capture_output=True, text=True, timeout=10
        )
        
        if result.returncode != 0:
            return {'controls': {}, 'categories': categories, 'error': result.stderr}
        
        current_control = None
        menu_items = {}
        
        for line in result.stdout.split('\n'):
            # Parse control lines like:
            # focus_automatic_continuous 0x009a090c (bool)   : default=0 value=1
            # brightness                 0x00980900 (int)    : min=-64 max=64 step=1 default=0 value=0
            # white_balance_automatic    0x0098090c (bool)   : default=1 value=1
            # power_line_frequency       0x00980918 (menu)   : min=0 max=2 default=1 value=1
            match = re.match(r'\s*(\w+)\s+0x[0-9a-f]+\s+\((\w+)\)\s*:\s*(.*)', line)
            if match:
                name = match.group(1)
                ctrl_type = match.group(2)
                attrs_str = match.group(3)
                
                control = {
                    'name': name,
                    'type': ctrl_type,
                    'display_name': name.replace('_', ' ').title()
                }
                
                # Parse attributes
                for attr in attrs_str.split():
                    if '=' in attr:
                        k, v = attr.split('=', 1)
                        # Convert numeric values
                        try:
                            if '.' in v:
                                control[k] = float(v)
                            else:
                                control[k] = int(v)
                        except ValueError:
                            control[k] = v
                
                # Determine category
                category = 'other'
                name_lower = name.lower()
                for cat, keywords in categories.items():
                    if cat != 'other' and any(kw in name_lower for kw in keywords):
                        category = cat
                        break
                control['category'] = category
                
                # Initialize menu items for menu controls
                if ctrl_type == 'menu':
                    control['menu_items'] = {}
                    current_control = name
                else:
                    current_control = None
                
                controls[name] = control
            
            # Parse menu items like:
            #                             0: Disabled
            #                             1: 50 Hz
            elif current_control and line.strip():
                menu_match = re.match(r'\s*(\d+):\s*(.+)', line)
                if menu_match and current_control in controls:
                    idx = int(menu_match.group(1))
                    label = menu_match.group(2).strip()
                    controls[current_control]['menu_items'][idx] = label
        
        # Group controls by category
        grouped = {cat: [] for cat in categories.keys()}
        for name, ctrl in controls.items():
            cat = ctrl.get('category', 'other')
            if cat in grouped:
                grouped[cat].append(ctrl)
            else:
                grouped['other'].append(ctrl)
        
        return {
            'controls': controls,
            'grouped': grouped,
            'categories': list(categories.keys())
        }
        
    except Exception as e:
        return {'controls': {}, 'error': str(e)}


# ============================================================================
# Camera Profiles Management
# ============================================================================

DEFAULT_CAMERA_PROFILES = {
    'day': {
        'name': 'Jour',
        'description': 'Profil pour conditions diurnes normales',
        'schedule': {'start': '07:00', 'end': '19:00'},
        'controls': {
            # Will be populated with current camera values on first save
        },
        'enabled': True
    },
    'night': {
        'name': 'Nuit (IR)',
        'description': 'Profil pour caméra IR en conditions nocturnes',
        'schedule': {'start': '19:00', 'end': '07:00'},
        'controls': {
            # Typical night/IR settings - will vary by camera
        },
        'enabled': True
    }
}


def get_profiles_path():
    """Get the camera profiles JSON file path."""
    config = load_config()
    return config.get('CAMERA_PROFILES_FILE', '/etc/rpi-cam/camera_profiles.json')


def load_camera_profiles():
    """Load camera profiles from JSON file."""
    profiles_path = get_profiles_path()
    
    try:
        if os.path.exists(profiles_path):
            with open(profiles_path, 'r') as f:
                return json.load(f)
        else:
            # Return default profiles
            return DEFAULT_CAMERA_PROFILES.copy()
    except Exception as e:
        print(f"Error loading camera profiles: {e}")
        return DEFAULT_CAMERA_PROFILES.copy()


def save_camera_profiles(profiles):
    """Save camera profiles to JSON file."""
    profiles_path = get_profiles_path()
    
    try:
        # Ensure directory exists
        os.makedirs(os.path.dirname(profiles_path), exist_ok=True)
        
        with open(profiles_path, 'w') as f:
            json.dump(profiles, f, indent=2)
        return True, "Profiles saved"
    except Exception as e:
        return False, str(e)


def apply_camera_profile(profile_name, device='/dev/video0'):
    """Apply a camera profile (set all its controls)."""
    global camera_profiles_state
    
    profiles = load_camera_profiles()
    
    if profile_name not in profiles:
        return False, f"Profile '{profile_name}' not found"
    
    profile = profiles[profile_name]
    controls = profile.get('controls', {})
    
    results = []
    for control_name, value in controls.items():
        success, msg = set_camera_control(device, control_name, value)
        results.append({
            'control': control_name,
            'value': value,
            'success': success,
            'message': msg
        })
    
    # Update shared state (works across Gunicorn workers)
    shared_state = load_scheduler_state()
    save_scheduler_state(
        shared_state.get('running', False),
        profile_name,
        time.time()
    )
    
    failed = [r for r in results if not r['success']]
    if failed:
        return True, f"Profile applied with {len(failed)} errors"
    return True, f"Profile '{profile_name}' applied successfully"


def get_current_profile_for_time(profiles, current_time=None):
    """Determine which profile should be active based on current time.
    
    Args:
        profiles: Dict of profiles
        current_time: datetime.time object (default: now)
    
    Returns:
        Profile name or None
    """
    if current_time is None:
        current_time = datetime.now().time()
    
    def time_to_minutes(t):
        """Convert time string (HH:MM) to minutes since midnight."""
        if isinstance(t, str):
            h, m = map(int, t.split(':'))
            return h * 60 + m
        return t.hour * 60 + t.minute
    
    current_minutes = time_to_minutes(current_time)
    
    for profile_name, profile in profiles.items():
        if not profile.get('enabled', False):
            continue
        
        schedule = profile.get('schedule', {})
        start = schedule.get('start')
        end = schedule.get('end')
        
        if not start or not end:
            continue
        
        start_minutes = time_to_minutes(start)
        end_minutes = time_to_minutes(end)
        
        # Handle overnight schedules (e.g., 19:00 to 07:00)
        if start_minutes > end_minutes:
            # Active if current time is after start OR before end
            if current_minutes >= start_minutes or current_minutes < end_minutes:
                return profile_name
        else:
            # Normal schedule (e.g., 07:00 to 19:00)
            if start_minutes <= current_minutes < end_minutes:
                return profile_name
    
    return None


def camera_profiles_scheduler_loop():
    """Background scheduler loop for camera profiles."""
    global camera_profiles_state
    
    print("[Camera Profiles] Scheduler started")
    
    while True:
        with camera_profiles_lock:
            if not camera_profiles_state['scheduler_running']:
                break
        
        try:
            config = load_config()
            if config.get('CAMERA_PROFILES_ENABLED', 'no') != 'yes':
                time.sleep(60)
                continue
            
            profiles = load_camera_profiles()
            device = config.get('VIDEO_DEVICE', '/dev/video0')
            
            # Determine which profile should be active
            target_profile = get_current_profile_for_time(profiles)
            
            # Get current active profile from shared state
            shared_state = load_scheduler_state()
            current_profile = shared_state.get('active_profile')
            
            # Apply profile if changed
            if target_profile and target_profile != current_profile:
                print(f"[Camera Profiles] Switching to profile: {target_profile}")
                success, msg = apply_camera_profile(target_profile, device)
                print(f"[Camera Profiles] {msg}")
                
                # Update shared state
                if success:
                    save_scheduler_state(True, target_profile, time.time())
            
        except Exception as e:
            print(f"[Camera Profiles] Scheduler error: {e}")
        
        # Check every minute
        time.sleep(60)
    
    # Mark as stopped in shared state
    save_scheduler_state(False)
    print("[Camera Profiles] Scheduler stopped")


def start_camera_profiles_scheduler():
    """Start the camera profiles scheduler thread."""
    global camera_profiles_thread, camera_profiles_state
    
    # Check if already running (in this or another worker)
    shared_state = load_scheduler_state()
    if shared_state.get('running') and shared_state.get('pid'):
        # Check if the PID is still alive
        try:
            os.kill(shared_state['pid'], 0)  # Signal 0 = check if process exists
            return False, "Scheduler already running in another worker"
        except OSError:
            # Process is dead, we can start
            pass
    
    with camera_profiles_lock:
        if camera_profiles_state['scheduler_running']:
            return False, "Scheduler already running"
        camera_profiles_state['scheduler_running'] = True
    
    # Save shared state
    save_scheduler_state(True)
    
    camera_profiles_thread = threading.Thread(
        target=camera_profiles_scheduler_loop,
        daemon=True,
        name='camera-profiles-scheduler'
    )
    camera_profiles_thread.start()
    return True, "Scheduler started"


def stop_camera_profiles_scheduler():
    """Stop the camera profiles scheduler thread."""
    global camera_profiles_state
    
    with camera_profiles_lock:
        camera_profiles_state['scheduler_running'] = False
    
    # Update shared state
    save_scheduler_state(False)
    
    return True, "Scheduler stopped"


# ============================================================================
# Flask Routes
# ============================================================================

@app.route('/')
def index():
    """Main dashboard page."""
    config = load_config()
    status = get_service_status()
    system_info = get_system_info()
    wifi_info = get_current_wifi()
    led_status = get_led_status()
    gpu_mem = get_gpu_mem()
    
    # Build RTSP URL for display (use preferred IP based on interface priority)
    rtsp_port = config.get('RTSP_PORT', '8554')
    rtsp_path = config.get('RTSP_PATH', 'stream')
    ip = get_preferred_ip()
    rtsp_url = f"rtsp://{ip}:{rtsp_port}/{rtsp_path}"
    
    # Get hostname for alternate URL
    hostname = system_info.get('hostname', '')
    rtsp_url_hostname = f"rtsp://{hostname}.local:{rtsp_port}/{rtsp_path}" if hostname else None
    
    # Check if device is provisioned (Meeting)
    is_provisioned = config.get('MEETING_PROVISIONED', 'no') == 'yes'
    
    return render_template('index.html', 
                         config=config, 
                         metadata=CONFIG_METADATA,
                         status=status,
                         system_info=system_info,
                         rtsp_url=rtsp_url,
                         rtsp_url_hostname=rtsp_url_hostname,
                         is_provisioned=is_provisioned,
                         wifi_info=wifi_info,
                         led_status=led_status,
                         gpu_mem=gpu_mem,
                         platform=PLATFORM)


@app.route('/api/config', methods=['GET'])
def api_get_config():
    """API endpoint to get current configuration."""
    config = load_config()
    return jsonify({
        'success': True,
        'config': config,
        'metadata': CONFIG_METADATA
    })


@app.route('/api/config', methods=['POST'])
def api_save_config():
    """API endpoint to save configuration."""
    try:
        data = request.get_json()
        config = load_config()
        
        # Update only valid keys
        for key, value in data.items():
            if key in DEFAULT_CONFIG:
                config[key] = str(value)
        
        save_config(config)
        # Keep ONVIF credentials in sync with RTSP credentials
        sync_onvif_credentials_from_rtsp(config)
        return jsonify({'success': True, 'message': 'Configuration sauvegardée'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/status', methods=['GET'])
def api_get_status():
    """API endpoint to get service status."""
    status = get_service_status()
    system_info = get_system_info()
    return jsonify({
        'success': True,
        'status': status,
        'system_info': system_info
    })


@app.route('/api/service/<action>', methods=['POST'])
def api_service_control(action):
    """API endpoint to control the service."""
    success, message = control_service(action)
    return jsonify({
        'success': success,
        'message': message,
        'status': get_service_status()
    })


@app.route('/api/logs', methods=['GET'])
def api_get_logs():
    """API endpoint to get recent logs."""
    lines = request.args.get('lines', 100, type=int)
    source = request.args.get('source', 'all')  # all, file, journald, gstreamer
    logs = get_recent_logs(lines, source)
    return jsonify({
        'success': True,
        'logs': logs
    })


@app.route('/api/logs/stream')
def api_stream_logs():
    """API endpoint for real-time log streaming via SSE."""
    return Response(
        stream_logs(),
        mimetype='text/event-stream',
        headers={
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'X-Accel-Buffering': 'no'
        }
    )


@app.route('/api/logs/clean', methods=['POST'])
def api_clean_logs():
    """API endpoint to clean/truncate log files."""
    try:
        config = load_config()
        log_dir = config.get('LOG_DIR', '/var/log/rpi-cam')
        log_file = os.path.join(log_dir, 'rpi_av_rtsp_recorder.log')
        
        cleaned_files = []
        freed_bytes = 0
        
        # Truncate main log file (keep last 100 lines)
        if os.path.exists(log_file):
            old_size = os.path.getsize(log_file)
            result = subprocess.run(
                f'tail -n 100 "{log_file}" > "{log_file}.tmp" && mv "{log_file}.tmp" "{log_file}"',
                shell=True, capture_output=True, timeout=10
            )
            if result.returncode == 0:
                new_size = os.path.getsize(log_file) if os.path.exists(log_file) else 0
                freed_bytes += old_size - new_size
                cleaned_files.append(f'rpi_av_rtsp_recorder.log (truncated)')
        
        # Remove GStreamer debug logs (they can be huge)
        gst_patterns = ['gstreamer*.log', 'gst_*.log', '*.log.1', '*.log.2']
        for pattern in gst_patterns:
            result = subprocess.run(
                f'find "{log_dir}" -name "{pattern}" -type f -exec rm -f {{}} \\;',
                shell=True, capture_output=True, timeout=10
            )
        
        # Clean old log files (> 7 days)
        result = subprocess.run(
            f'find "{log_dir}" -type f -name "*.log" -mtime +7 -delete',
            shell=True, capture_output=True, timeout=10
        )
        
        # Clean /tmp GStreamer cache files
        result = subprocess.run(
            'find /tmp -name "gst-*" -mtime +1 -delete 2>/dev/null || true',
            shell=True, capture_output=True, timeout=10
        )
        
        # Vacuum journald logs
        result = subprocess.run(
            ['journalctl', '--vacuum-size=50M'],
            capture_output=True, timeout=30
        )
        if result.returncode == 0:
            cleaned_files.append('journald (vacuumed)')
        
        return jsonify({
            'success': True,
            'message': f'Logs nettoyés: {", ".join(cleaned_files) if cleaned_files else "aucun fichier"}',
            'freed_bytes': freed_bytes
        })
        
    except subprocess.TimeoutExpired:
        return jsonify({
            'success': False,
            'message': 'Timeout lors du nettoyage des logs'
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'Erreur: {str(e)}'
        })


@app.route('/api/diagnostic', methods=['GET'])
def api_diagnostic():
    """API endpoint to get diagnostic information."""
    diag = get_diagnostic_info()
    return jsonify({
        'success': True,
        'diagnostic': diag
    })


@app.route('/api/recordings', methods=['GET'])
def api_get_recordings():
    """API endpoint to list recordings."""
    config = load_config()
    record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
    
    recordings = []
    try:
        if os.path.exists(record_dir):
            files = sorted(Path(record_dir).glob('*.ts'), key=lambda x: x.stat().st_mtime, reverse=True)
            for f in files[:100]:  # Limit to last 100
                stat = f.stat()
                recordings.append({
                    'name': f.name,
                    'size_mb': round(stat.st_size / (1024 * 1024), 2),
                    'modified': stat.st_mtime
                })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500
    
    return jsonify({
        'success': True,
        'recordings': recordings,
        'directory': record_dir
    })


# ============================================================================
# Recordings Management API (enhanced for Files tab)
# ============================================================================

LOCKED_FILES_PATH = '/etc/rpi-cam/locked_recordings.json'


def load_locked_files():
    """Load list of locked recording files."""
    try:
        if os.path.exists(LOCKED_FILES_PATH):
            with open(LOCKED_FILES_PATH, 'r') as f:
                return set(json.load(f))
    except Exception as e:
        print(f"[Recordings] Error loading locked files: {e}")
    return set()


def save_locked_files(locked_files):
    """Save list of locked recording files."""
    try:
        os.makedirs(os.path.dirname(LOCKED_FILES_PATH), exist_ok=True)
        with open(LOCKED_FILES_PATH, 'w') as f:
            json.dump(list(locked_files), f)
        return True
    except Exception as e:
        print(f"[Recordings] Error saving locked files: {e}")
        return False


def is_valid_recording_filename(filename):
    """Check if filename is a valid recording file (security)."""
    if '..' in filename or '/' in filename or '\\' in filename:
        return False
    # Allow .ts and .mp4 files
    valid_extensions = ('.ts', '.mp4', '.mkv', '.avi')
    return filename.lower().endswith(valid_extensions)


@app.route('/api/recordings/list', methods=['GET'])
def api_list_recordings():
    """API endpoint to list recordings with pagination support."""
    config = load_config()
    record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
    locked_files = load_locked_files()
    
    # Pagination parameters
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    
    # Limit per_page to reasonable bounds
    per_page = max(5, min(100, per_page))
    
    # Filter and sort parameters (applied before pagination)
    filter_type = request.args.get('filter', 'all')  # all, locked, unlocked
    sort_by = request.args.get('sort', 'date-desc')  # date-desc, date-asc, name-asc, name-desc, size-desc, size-asc
    search_query = request.args.get('search', '').strip().lower()
    
    all_recordings = []
    total_size = 0
    
    try:
        if os.path.exists(record_dir):
            # Get all video files
            video_extensions = ('*.ts', '*.mp4', '*.mkv', '*.avi')
            all_files = []
            for ext in video_extensions:
                all_files.extend(Path(record_dir).glob(ext))
            
            for f in all_files:
                try:
                    stat = f.stat()
                    size_bytes = stat.st_size
                    total_size += size_bytes
                    is_locked = f.name in locked_files
                    
                    # Apply filter
                    if filter_type == 'locked' and not is_locked:
                        continue
                    if filter_type == 'unlocked' and is_locked:
                        continue
                    
                    # Apply search
                    if search_query and search_query not in f.name.lower():
                        continue
                    
                    all_recordings.append({
                        'name': f.name,
                        'size_bytes': size_bytes,
                        'size_mb': round(size_bytes / (1024 * 1024), 2),
                        'size_display': format_file_size(size_bytes),
                        'modified': stat.st_mtime,
                        'modified_iso': datetime.fromtimestamp(stat.st_mtime).isoformat(),
                        'modified_display': datetime.fromtimestamp(stat.st_mtime).strftime('%d/%m/%Y %H:%M'),
                        'locked': is_locked,
                        'extension': f.suffix.lower()
                    })
                except Exception as e:
                    print(f"[Recordings] Error reading file {f}: {e}")
                    continue
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500
    
    # Apply sorting
    if sort_by == 'date-desc':
        all_recordings.sort(key=lambda x: x['modified'], reverse=True)
    elif sort_by == 'date-asc':
        all_recordings.sort(key=lambda x: x['modified'])
    elif sort_by == 'name-asc':
        all_recordings.sort(key=lambda x: x['name'].lower())
    elif sort_by == 'name-desc':
        all_recordings.sort(key=lambda x: x['name'].lower(), reverse=True)
    elif sort_by == 'size-desc':
        all_recordings.sort(key=lambda x: x['size_bytes'], reverse=True)
    elif sort_by == 'size-asc':
        all_recordings.sort(key=lambda x: x['size_bytes'])
    
    # Calculate pagination
    total_filtered = len(all_recordings)
    total_pages = max(1, (total_filtered + per_page - 1) // per_page)
    page = max(1, min(page, total_pages))
    
    start_idx = (page - 1) * per_page
    end_idx = start_idx + per_page
    paginated_recordings = all_recordings[start_idx:end_idx]
    
    # Get disk space info
    disk_info = {}
    try:
        if os.path.exists(record_dir):
            result = subprocess.run(['df', '-B1', record_dir], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                if len(lines) >= 2:
                    parts = lines[1].split()
                    if len(parts) >= 4:
                        disk_info = {
                            'total': int(parts[1]),
                            'used': int(parts[2]),
                            'available': int(parts[3]),
                            'total_display': format_file_size(int(parts[1])),
                            'available_display': format_file_size(int(parts[3]))
                        }
    except:
        pass
    
    # Calculate usable space (disk available minus safety margin)
    min_free_mb = int(config.get('MIN_FREE_DISK_MB', 1000))
    min_free_bytes = min_free_mb * 1024 * 1024
    disk_available = disk_info.get('available', 0)
    # Usable = disk available - safety margin (cannot be negative)
    usable_bytes = max(0, disk_available - min_free_bytes)
    
    storage_info = {
        'disk_available_bytes': disk_available,
        'disk_available_display': format_file_size(disk_available),
        'min_free_bytes': min_free_bytes,
        'min_free_display': format_file_size(min_free_bytes),
        'usable_bytes': usable_bytes,
        'usable_display': format_file_size(usable_bytes),
        'recordings_size_bytes': total_size,
        'recordings_size_display': format_file_size(total_size),
        'disk_full': disk_available < min_free_bytes  # Flag to show warning
    }
    
    return jsonify({
        'success': True,
        'recordings': paginated_recordings,
        'pagination': {
            'page': page,
            'per_page': per_page,
            'total_pages': total_pages,
            'total_filtered': total_filtered,
            'has_prev': page > 1,
            'has_next': page < total_pages,
            'start_index': start_idx + 1 if total_filtered > 0 else 0,
            'end_index': min(end_idx, total_filtered)
        },
        'total_count': total_filtered,
        'total_size': total_size,
        'total_size_display': format_file_size(total_size),
        'directory': record_dir,
        'disk_info': disk_info,
        'storage_info': storage_info
    })


def format_file_size(size_bytes):
    """Format file size in human readable format."""
    for unit in ['o', 'Ko', 'Mo', 'Go', 'To']:
        if abs(size_bytes) < 1024.0:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f} Po"


@app.route('/api/recordings/delete', methods=['POST'])
def api_delete_recordings():
    """API endpoint to delete recordings."""
    try:
        data = request.get_json()
        files = data.get('files', [])
        force = data.get('force', False)  # Force delete even if locked
        
        config = load_config()
        record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
        locked_files = load_locked_files()
        
        deleted = 0
        skipped_locked = []
        errors = []
        
        for filename in files:
            # Security: validate filename
            if not is_valid_recording_filename(filename):
                errors.append(f"{filename}: nom de fichier invalide")
                continue
            
            # Check if locked (unless force)
            if filename in locked_files and not force:
                skipped_locked.append(filename)
                continue
            
            filepath = os.path.join(record_dir, filename)
            if os.path.exists(filepath):
                try:
                    os.remove(filepath)
                    deleted += 1
                    # Also remove from locked files if it was there
                    if filename in locked_files:
                        locked_files.discard(filename)
                except Exception as e:
                    errors.append(f"{filename}: {str(e)}")
        
        # Save updated locked files
        if locked_files != load_locked_files():
            save_locked_files(locked_files)
        
        return jsonify({
            'success': True, 
            'deleted': deleted,
            'skipped_locked': skipped_locked,
            'errors': errors
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/recordings/lock', methods=['POST'])
def api_lock_recordings():
    """API endpoint to lock/unlock recordings (prevent deletion)."""
    try:
        data = request.get_json()
        files = data.get('files', [])
        lock = data.get('lock', True)  # True to lock, False to unlock
        
        config = load_config()
        record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
        locked_files = load_locked_files()
        
        modified = 0
        for filename in files:
            # Security: validate filename
            if not is_valid_recording_filename(filename):
                continue
            
            # Check file exists
            filepath = os.path.join(record_dir, filename)
            if not os.path.exists(filepath):
                continue
            
            if lock and filename not in locked_files:
                locked_files.add(filename)
                modified += 1
            elif not lock and filename in locked_files:
                locked_files.discard(filename)
                modified += 1
        
        save_locked_files(locked_files)
        
        return jsonify({
            'success': True,
            'modified': modified,
            'action': 'locked' if lock else 'unlocked'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/recordings/download/<filename>', methods=['GET'])
def api_download_recording(filename):
    """API endpoint to download a recording file."""
    try:
        # Security: validate filename
        if not is_valid_recording_filename(filename):
            return jsonify({'success': False, 'message': 'Nom de fichier invalide'}), 400
        
        config = load_config()
        record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
        filepath = os.path.join(record_dir, filename)
        
        if not os.path.exists(filepath):
            return jsonify({'success': False, 'message': 'Fichier non trouvé'}), 404
        
        # Determine MIME type
        mime_types = {
            '.ts': 'video/mp2t',
            '.mp4': 'video/mp4',
            '.mkv': 'video/x-matroska',
            '.avi': 'video/x-msvideo'
        }
        ext = os.path.splitext(filename)[1].lower()
        mimetype = mime_types.get(ext, 'application/octet-stream')
        
        from flask import send_file
        return send_file(
            filepath,
            mimetype=mimetype,
            as_attachment=True,
            download_name=filename
        )
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/recordings/stream/<filename>', methods=['GET'])
def api_stream_recording(filename):
    """API endpoint to stream a recording for playback."""
    try:
        # Security: validate filename
        if not is_valid_recording_filename(filename):
            return jsonify({'success': False, 'message': 'Nom de fichier invalide'}), 400
        
        config = load_config()
        record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
        filepath = os.path.join(record_dir, filename)
        
        if not os.path.exists(filepath):
            return jsonify({'success': False, 'message': 'Fichier non trouvé'}), 404
        
        # Determine MIME type
        mime_types = {
            '.ts': 'video/mp2t',
            '.mp4': 'video/mp4',
            '.mkv': 'video/x-matroska',
            '.avi': 'video/x-msvideo'
        }
        ext = os.path.splitext(filename)[1].lower()
        mimetype = mime_types.get(ext, 'video/mp2t')
        
        # Support range requests for seeking
        file_size = os.path.getsize(filepath)
        range_header = request.headers.get('Range', None)
        
        if range_header:
            # Parse range header
            byte_start = 0
            byte_end = file_size - 1
            
            match = re.match(r'bytes=(\d+)-(\d*)', range_header)
            if match:
                byte_start = int(match.group(1))
                if match.group(2):
                    byte_end = int(match.group(2))
            
            length = byte_end - byte_start + 1
            
            def generate_range():
                with open(filepath, 'rb') as f:
                    f.seek(byte_start)
                    remaining = length
                    chunk_size = 8192
                    while remaining > 0:
                        read_size = min(chunk_size, remaining)
                        data = f.read(read_size)
                        if not data:
                            break
                        remaining -= len(data)
                        yield data
            
            response = Response(
                generate_range(),
                status=206,
                mimetype=mimetype,
                direct_passthrough=True
            )
            response.headers['Content-Range'] = f'bytes {byte_start}-{byte_end}/{file_size}'
            response.headers['Accept-Ranges'] = 'bytes'
            response.headers['Content-Length'] = length
            return response
        
        # Full file response
        def generate_file():
            with open(filepath, 'rb') as f:
                while True:
                    chunk = f.read(8192)
                    if not chunk:
                        break
                    yield chunk
        
        response = Response(
            generate_file(),
            mimetype=mimetype,
            direct_passthrough=True
        )
        response.headers['Accept-Ranges'] = 'bytes'
        response.headers['Content-Length'] = file_size
        return response
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/recordings/info/<filename>', methods=['GET'])
def api_recording_info(filename):
    """API endpoint to get detailed info about a recording."""
    try:
        # Security: validate filename
        if not is_valid_recording_filename(filename):
            return jsonify({'success': False, 'message': 'Nom de fichier invalide'}), 400
        
        config = load_config()
        record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
        filepath = os.path.join(record_dir, filename)
        
        if not os.path.exists(filepath):
            return jsonify({'success': False, 'message': 'Fichier non trouvé'}), 404
        
        locked_files = load_locked_files()
        stat = os.stat(filepath)
        
        info = {
            'name': filename,
            'path': filepath,
            'size_bytes': stat.st_size,
            'size_display': format_file_size(stat.st_size),
            'created': stat.st_ctime,
            'modified': stat.st_mtime,
            'modified_display': datetime.fromtimestamp(stat.st_mtime).strftime('%d/%m/%Y %H:%M:%S'),
            'locked': filename in locked_files,
            'extension': os.path.splitext(filename)[1].lower()
        }
        
        # Try to get video duration using ffprobe
        try:
            result = subprocess.run(
                ['ffprobe', '-v', 'error', '-show_entries', 'format=duration',
                 '-of', 'default=noprint_wrappers=1:nokey=1', filepath],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0 and result.stdout.strip():
                duration = float(result.stdout.strip())
                info['duration_seconds'] = duration
                minutes, seconds = divmod(int(duration), 60)
                hours, minutes = divmod(minutes, 60)
                if hours > 0:
                    info['duration_display'] = f'{hours}h {minutes:02d}m {seconds:02d}s'
                else:
                    info['duration_display'] = f'{minutes}m {seconds:02d}s'
        except:
            pass
        
        return jsonify({'success': True, 'info': info})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# Thumbnail cache directory
THUMBNAIL_CACHE_DIR = '/var/cache/rpi-cam/thumbnails'


def get_thumbnail_path(filename):
    """Get the path to the thumbnail for a recording."""
    # Replace extension with .jpg
    thumb_name = os.path.splitext(filename)[0] + '.jpg'
    return os.path.join(THUMBNAIL_CACHE_DIR, thumb_name)


def generate_thumbnail(video_path, thumb_path, timestamp=2):
    """Generate a thumbnail from a video file using ffmpeg."""
    try:
        # Create thumbnail directory if needed
        os.makedirs(os.path.dirname(thumb_path), exist_ok=True)
        
        # Use ffmpeg to extract a frame
        # -ss 2 : seek to 2 seconds (avoid black frames at start)
        # -vframes 1 : extract only 1 frame
        # -vf scale=320:-1 : scale to 320px width, keep aspect ratio
        result = subprocess.run([
            'ffmpeg', '-y',
            '-ss', str(timestamp),
            '-i', video_path,
            '-vframes', '1',
            '-vf', 'scale=320:-1',
            '-q:v', '3',
            thumb_path
        ], capture_output=True, text=True, timeout=30)
        
        if result.returncode == 0 and os.path.exists(thumb_path):
            return True
        
        # If seeking to 2s fails (short video), try at 0
        if timestamp > 0:
            return generate_thumbnail(video_path, thumb_path, timestamp=0)
            
        return False
    except Exception as e:
        print(f"[Thumbnail] Error generating thumbnail: {e}")
        return False


@app.route('/api/recordings/thumbnail/<filename>', methods=['GET'])
def api_recording_thumbnail(filename):
    """API endpoint to get or generate a thumbnail for a recording."""
    try:
        # Security: validate filename
        if not is_valid_recording_filename(filename):
            return jsonify({'success': False, 'message': 'Nom de fichier invalide'}), 400
        
        config = load_config()
        record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
        video_path = os.path.join(record_dir, filename)
        
        if not os.path.exists(video_path):
            return jsonify({'success': False, 'message': 'Fichier non trouvé'}), 404
        
        thumb_path = get_thumbnail_path(filename)
        video_mtime = os.path.getmtime(video_path)
        
        # Check if thumbnail exists and is up to date
        need_generate = True
        if os.path.exists(thumb_path):
            thumb_mtime = os.path.getmtime(thumb_path)
            # If thumbnail is newer than video, it's valid
            if thumb_mtime >= video_mtime:
                need_generate = False
        
        # Generate thumbnail if needed
        if need_generate:
            if not generate_thumbnail(video_path, thumb_path):
                # Return a placeholder or error
                return jsonify({'success': False, 'message': 'Impossible de générer la miniature'}), 500
        
        # Return the thumbnail image
        from flask import send_file
        return send_file(
            thumb_path,
            mimetype='image/jpeg',
            as_attachment=False
        )
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/recordings/thumbnails/generate', methods=['POST'])
def api_generate_thumbnails():
    """API endpoint to batch generate thumbnails for all recordings."""
    try:
        config = load_config()
        record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
        
        generated = 0
        skipped = 0
        errors = 0
        
        if os.path.exists(record_dir):
            video_extensions = ('*.ts', '*.mp4', '*.mkv', '*.avi')
            all_files = []
            for ext in video_extensions:
                all_files.extend(Path(record_dir).glob(ext))
            
            for video_file in all_files:
                thumb_path = get_thumbnail_path(video_file.name)
                video_mtime = video_file.stat().st_mtime
                
                # Skip if thumbnail exists and is current
                if os.path.exists(thumb_path):
                    thumb_mtime = os.path.getmtime(thumb_path)
                    if thumb_mtime >= video_mtime:
                        skipped += 1
                        continue
                
                # Generate thumbnail
                if generate_thumbnail(str(video_file), thumb_path):
                    generated += 1
                else:
                    errors += 1
        
        return jsonify({
            'success': True,
            'generated': generated,
            'skipped': skipped,
            'errors': errors
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/recordings/thumbnails/clean', methods=['POST'])
def api_clean_thumbnails():
    """API endpoint to clean orphaned thumbnails."""
    try:
        config = load_config()
        record_dir = config.get('RECORD_DIR', '/var/cache/rpi-cam/recordings')
        
        deleted = 0
        
        if os.path.exists(THUMBNAIL_CACHE_DIR):
            for thumb_file in Path(THUMBNAIL_CACHE_DIR).glob('*.jpg'):
                # Find corresponding video
                base_name = thumb_file.stem
                has_video = False
                for ext in ['.ts', '.mp4', '.mkv', '.avi']:
                    if os.path.exists(os.path.join(record_dir, base_name + ext)):
                        has_video = True
                        break
                
                # Delete orphaned thumbnail
                if not has_video:
                    thumb_file.unlink()
                    deleted += 1
        
        return jsonify({'success': True, 'deleted': deleted})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/detect/cameras', methods=['GET'])
def api_detect_cameras():
    """API endpoint to detect available cameras."""
    cameras = []
    
    # Check USB cameras
    for i in range(4):
        dev = f'/dev/video{i}'
        if os.path.exists(dev):
            info = {'device': dev, 'type': 'USB'}
            try:
                result = subprocess.run(
                    ['v4l2-ctl', '-d', dev, '--info'],
                    capture_output=True, text=True, timeout=5
                )
                if 'Card type' in result.stdout:
                    for line in result.stdout.split('\n'):
                        if 'Card type' in line:
                            info['name'] = line.split(':')[1].strip()
                            break
            except:
                info['name'] = f'Video Device {i}'
            cameras.append(info)
    
    # Check CSI camera (Raspberry Pi only)
    if PLATFORM['has_libcamera']:
        try:
            result = subprocess.run(
                ['libcamera-hello', '--list-cameras'],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0 and 'Available cameras' in result.stdout:
                cameras.append({'device': 'CSI', 'type': 'CSI', 'name': 'Raspberry Pi Camera'})
        except:
            pass
    
    return jsonify({'success': True, 'cameras': cameras})


@app.route('/api/detect/audio', methods=['GET'])
def api_detect_audio():
    """API endpoint to detect available audio devices."""
    devices = []
    
    try:
        result = subprocess.run(
            ['arecord', '-l'],
            capture_output=True, text=True, timeout=5
        )
        
        for line in result.stdout.split('\n'):
            if line.startswith('card '):
                parts = line.split(':')
                if len(parts) >= 2:
                    card_num = parts[0].replace('card ', '').strip()
                    device_info = parts[1].strip()
                    devices.append({
                        'device': f'plughw:{card_num},0',
                        'name': device_info
                    })
    except:
        pass
    
    return jsonify({'success': True, 'devices': devices})


@app.route('/api/camera/controls', methods=['GET'])
def api_camera_controls():
    """API endpoint to get camera controls."""
    device = request.args.get('device', '/dev/video0')
    controls = get_camera_controls(device)
    autofocus = get_camera_autofocus_status(device)
    return jsonify({
        'success': True,
        'device': device,
        'controls': controls,
        'autofocus': autofocus
    })


@app.route('/api/camera/autofocus', methods=['GET'])
def api_camera_autofocus_get():
    """API endpoint to get autofocus status."""
    device = request.args.get('device', '/dev/video0')
    status = get_camera_autofocus_status(device)
    return jsonify({'success': True, 'autofocus': status})


@app.route('/api/camera/autofocus', methods=['POST'])
def api_camera_autofocus_set():
    """API endpoint to set autofocus (with persistence)."""
    try:
        data = request.get_json()
        device = data.get('device', '/dev/video0')
        enabled = data.get('enabled', True)
        persist = data.get('persist', True)  # Save to config by default
        
        success, message = set_camera_autofocus(device, enabled, persist=persist)
        return jsonify({
            'success': success,
            'message': message,
            'enabled': enabled,
            'persisted': persist and success
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/camera/focus', methods=['POST'])
def api_camera_focus_set():
    """API endpoint to set manual focus."""
    try:
        data = request.get_json()
        device = data.get('device', '/dev/video0')
        value = data.get('value', 30)
        
        # First disable autofocus
        set_camera_autofocus(device, False)
        
        # Then set manual focus
        success, message = set_camera_focus(device, value)
        return jsonify({
            'success': success,
            'message': message,
            'value': value
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/camera/control', methods=['POST'])
def api_camera_control_set():
    """API endpoint to set any camera control."""
    try:
        data = request.get_json()
        device = data.get('device', '/dev/video0')
        control = data.get('control', '')
        value = data.get('value', 0)
        
        if not control:
            return jsonify({'success': False, 'message': 'Control name required'}), 400
        
        success, message = set_camera_control(device, control, value)
        return jsonify({
            'success': success,
            'message': message,
            'control': control,
            'value': value
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/camera/formats', methods=['GET'])
def api_camera_formats():
    """API endpoint to get available camera formats and resolutions."""
    device = request.args.get('device', '/dev/video0')
    formats = get_camera_formats(device)
    
    # Also get current config for reference
    config = load_config()
    current = {
        'width': int(config.get('VIDEO_WIDTH', 640)),
        'height': int(config.get('VIDEO_HEIGHT', 480)),
        'fps': int(config.get('VIDEO_FPS', 15))
    }
    
    return jsonify({
        'success': True,
        'device': device,
        'formats': formats,
        'current': current
    })


@app.route('/api/camera/oneshot-focus', methods=['POST'])
def api_camera_oneshot_focus():
    """API endpoint to trigger one-shot autofocus."""
    try:
        data = request.get_json() or {}
        device = data.get('device', '/dev/video0')
        
        success, message = trigger_one_shot_focus(device)
        return jsonify({
            'success': success,
            'message': message
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/camera/all-controls', methods=['GET'])
def api_camera_all_controls():
    """API endpoint to get ALL camera controls for advanced settings."""
    device = request.args.get('device', '/dev/video0')
    data = get_all_camera_controls(device)
    
    return jsonify({
        'success': 'error' not in data,
        'device': device,
        **data
    })


@app.route('/api/camera/controls/set-multiple', methods=['POST'])
def api_camera_set_multiple_controls():
    """API endpoint to set multiple camera controls at once."""
    try:
        data = request.get_json()
        device = data.get('device', '/dev/video0')
        controls = data.get('controls', {})
        
        results = []
        for name, value in controls.items():
            success, msg = set_camera_control(device, name, value)
            results.append({
                'control': name,
                'value': value,
                'success': success,
                'message': msg
            })
        
        failed = [r for r in results if not r['success']]
        return jsonify({
            'success': len(failed) == 0,
            'results': results,
            'errors': len(failed)
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# Camera Profiles API Routes
# ============================================================================

@app.route('/api/camera/profiles', methods=['GET'])
def api_camera_profiles_get():
    """Get all camera profiles."""
    profiles = load_camera_profiles()
    
    # Read from shared state file (works across Gunicorn workers)
    shared_state = load_scheduler_state()
    
    # Check if the scheduler process is still alive
    scheduler_running = False
    if shared_state.get('running') and shared_state.get('pid'):
        try:
            os.kill(shared_state['pid'], 0)
            scheduler_running = True
        except OSError:
            pass
    
    config = load_config()
    
    return jsonify({
        'success': True,
        'profiles': profiles,
        'active_profile': shared_state.get('active_profile'),
        'scheduler_enabled': config.get('CAMERA_PROFILES_ENABLED', 'no') == 'yes',
        'scheduler_running': scheduler_running,
        'last_profile_change': shared_state.get('last_change')
    })


@app.route('/api/camera/profiles', methods=['POST'])
def api_camera_profiles_save():
    """Save all camera profiles."""
    try:
        data = request.get_json()
        profiles = data.get('profiles', {})
        
        success, message = save_camera_profiles(profiles)
        
        # Reload profiles in memory
        if success:
            with camera_profiles_lock:
                camera_profiles_state['profiles'] = profiles
        
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/camera/profiles/<profile_name>', methods=['GET'])
def api_camera_profile_get(profile_name):
    """Get a specific camera profile."""
    profiles = load_camera_profiles()
    
    if profile_name not in profiles:
        return jsonify({'success': False, 'message': 'Profile not found'}), 404
    
    return jsonify({
        'success': True,
        'profile_name': profile_name,
        'profile': profiles[profile_name]
    })


@app.route('/api/camera/profiles/<profile_name>', methods=['PUT'])
def api_camera_profile_update(profile_name):
    """Update or create a camera profile."""
    try:
        data = request.get_json()
        profiles = load_camera_profiles()
        
        profiles[profile_name] = data
        success, message = save_camera_profiles(profiles)
        
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/camera/profiles/<profile_name>', methods=['DELETE'])
def api_camera_profile_delete(profile_name):
    """Delete a camera profile."""
    try:
        profiles = load_camera_profiles()
        
        if profile_name not in profiles:
            return jsonify({'success': False, 'message': 'Profile not found'}), 404
        
        del profiles[profile_name]
        success, message = save_camera_profiles(profiles)
        
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/camera/profiles/<profile_name>/apply', methods=['POST'])
def api_camera_profile_apply(profile_name):
    """Apply a camera profile immediately."""
    try:
        data = request.get_json() or {}
        device = data.get('device', '/dev/video0')
        
        success, message = apply_camera_profile(profile_name, device)
        
        return jsonify({
            'success': success,
            'message': message,
            'profile_name': profile_name
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/camera/profiles/<profile_name>/capture', methods=['POST'])
def api_camera_profile_capture(profile_name):
    """Capture current camera settings into a profile."""
    try:
        data = request.get_json() or {}
        device = data.get('device', '/dev/video0')
        
        # Get all current controls
        all_controls = get_all_camera_controls(device)
        
        if 'error' in all_controls:
            return jsonify({'success': False, 'message': all_controls['error']}), 500
        
        # Extract current values
        controls_to_save = {}
        for name, ctrl in all_controls.get('controls', {}).items():
            if 'value' in ctrl:
                controls_to_save[name] = ctrl['value']
        
        # Load profiles and update
        profiles = load_camera_profiles()
        
        if profile_name not in profiles:
            profiles[profile_name] = {
                'name': profile_name.replace('_', ' ').title(),
                'description': 'Custom profile',
                'schedule': {'start': '', 'end': ''},
                'enabled': False
            }
        
        profiles[profile_name]['controls'] = controls_to_save
        success, message = save_camera_profiles(profiles)
        
        return jsonify({
            'success': success,
            'message': f"Captured {len(controls_to_save)} controls into profile",
            'controls_count': len(controls_to_save)
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/camera/profiles/scheduler/start', methods=['POST'])
def api_camera_profiles_scheduler_start():
    """Start the camera profiles scheduler."""
    success, message = start_camera_profiles_scheduler()
    return jsonify({'success': success, 'message': message})


@app.route('/api/camera/profiles/scheduler/stop', methods=['POST'])
def api_camera_profiles_scheduler_stop():
    """Stop the camera profiles scheduler."""
    success, message = stop_camera_profiles_scheduler()
    return jsonify({'success': success, 'message': message})


@app.route('/api/camera/profiles/scheduler/status', methods=['GET'])
def api_camera_profiles_scheduler_status():
    """Get camera profiles scheduler status."""
    # Read from shared state file (works across Gunicorn workers)
    shared_state = load_scheduler_state()
    
    # Check if the scheduler process is still alive
    scheduler_running = False
    if shared_state.get('running') and shared_state.get('pid'):
        try:
            os.kill(shared_state['pid'], 0)  # Signal 0 = check if process exists
            scheduler_running = True
        except OSError:
            # Process is dead
            scheduler_running = False
    
    status = {
        'scheduler_running': scheduler_running,
        'active_profile': shared_state.get('active_profile'),
        'last_profile_change': shared_state.get('last_change')
    }
    
    config = load_config()
    status['scheduler_enabled'] = config.get('CAMERA_PROFILES_ENABLED', 'no') == 'yes'
    
    # Calculate which profile should be active now
    profiles = load_camera_profiles()
    status['expected_profile'] = get_current_profile_for_time(profiles)
    
    return jsonify({'success': True, 'status': status})


@app.route('/api/platform', methods=['GET'])
def api_platform():
    """API endpoint to get platform information."""
    return jsonify({
        'success': True,
        'platform': PLATFORM
    })


# ============================================================================
# Video Preview API Endpoints
# ============================================================================

# Global state for preview process management
preview_processes = {}
preview_lock = threading.Lock()


def generate_mjpeg_stream(source_type='camera', rtsp_url=None, device='/dev/video0', width=640, height=480, fps=10):
    """
    Generate MJPEG stream from camera or RTSP source using ffmpeg.
    Yields MJPEG frames in multipart format for browser display.
    """
    
    if source_type == 'rtsp' and rtsp_url:
        # Stream from RTSP source (relay the existing RTSP stream)
        cmd = [
            'ffmpeg',
            '-rtsp_transport', 'tcp',
            '-i', rtsp_url,
            '-f', 'mjpeg',
            '-q:v', '5',  # Quality (2-31, lower is better)
            '-r', str(fps),
            '-s', f'{width}x{height}',
            '-an',  # No audio
            '-'
        ]
    else:
        # Stream directly from camera device
        cmd = [
            'ffmpeg',
            '-f', 'v4l2',
            '-input_format', 'mjpeg',
            '-video_size', f'{width}x{height}',
            '-framerate', str(fps),
            '-i', device,
            '-f', 'mjpeg',
            '-q:v', '5',
            '-r', str(fps),
            '-'
        ]
    
    process = None
    try:
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,  # Suppress ffmpeg logs
            bufsize=10**6
        )
        
        # Read JPEG frames from ffmpeg output
        # MJPEG frames start with FFD8 and end with FFD9
        buffer = b''
        while True:
            chunk = process.stdout.read(4096)
            if not chunk:
                break
            buffer += chunk
            
            # Find complete JPEG frames
            while True:
                start = buffer.find(b'\xff\xd8')
                if start == -1:
                    buffer = b''
                    break
                    
                end = buffer.find(b'\xff\xd9', start + 2)
                if end == -1:
                    buffer = buffer[start:]
                    break
                
                frame = buffer[start:end + 2]
                buffer = buffer[end + 2:]
                
                # Yield as multipart MJPEG
                yield (b'--frame\r\n'
                       b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')
                       
    except Exception as e:
        print(f"[Preview] Error in MJPEG stream: {e}")
    finally:
        if process:
            process.terminate()
            try:
                process.wait(timeout=2)
            except:
                process.kill()


@app.route('/api/video/preview/stream')
def api_video_preview_stream():
    """
    Stream live MJPEG preview of the camera.
    Query params:
    - source: 'camera' (direct) or 'rtsp' (via RTSP server) - auto-detected if service running
    - width: preview width (default 640)
    - height: preview height (default 480)
    - fps: frames per second (default 10)
    """
    source = request.args.get('source', 'auto')
    width = int(request.args.get('width', 640))
    height = int(request.args.get('height', 480))
    fps = int(request.args.get('fps', 10))
    
    config = load_config()
    device = config.get('VIDEO_DEVICE', '/dev/video0')
    
    # Auto-detect: use RTSP if service is running (camera is busy)
    rtsp_running = get_service_status() == 'active'
    if source == 'auto':
        source = 'rtsp' if rtsp_running else 'camera'
    
    rtsp_url = None
    if source == 'rtsp':
        # Build RTSP URL from config
        rtsp_port = config.get('RTSP_PORT', '8554')
        rtsp_path = config.get('RTSP_PATH', 'stream')
        rtsp_url = f"rtsp://127.0.0.1:{rtsp_port}/{rtsp_path}"
    
    return Response(
        generate_mjpeg_stream(source, rtsp_url, device, width, height, fps),
        mimetype='multipart/x-mixed-replace; boundary=frame'
    )


@app.route('/api/video/preview/snapshot')
def api_video_preview_snapshot():
    """
    Capture a single snapshot from the camera or RTSP stream.
    Returns a JPEG image.
    Auto-detects if RTSP service is running and uses that source.
    """
    config = load_config()
    device = config.get('VIDEO_DEVICE', '/dev/video0')
    width = int(request.args.get('width', 640))
    height = int(request.args.get('height', 480))
    
    # Check if RTSP service is running (camera would be busy)
    rtsp_running = get_service_status() == 'active'
    
    try:
        if rtsp_running:
            # Capture from RTSP stream
            rtsp_port = config.get('RTSP_PORT', '8554')
            rtsp_path = config.get('RTSP_PATH', 'stream')
            rtsp_url = f"rtsp://127.0.0.1:{rtsp_port}/{rtsp_path}"
            
            cmd = [
                'ffmpeg',
                '-rtsp_transport', 'tcp',
                '-i', rtsp_url,
                '-frames:v', '1',
                '-s', f'{width}x{height}',
                '-f', 'image2',
                '-'
            ]
        else:
            # Capture directly from camera
            cmd = [
                'ffmpeg',
                '-f', 'v4l2',
                '-input_format', 'mjpeg',
                '-video_size', f'{width}x{height}',
                '-i', device,
                '-frames:v', '1',
                '-f', 'image2',
                '-'
            ]
        
        result = subprocess.run(cmd, capture_output=True, timeout=10)
        
        if result.returncode == 0 and result.stdout:
            return Response(result.stdout, mimetype='image/jpeg')
        else:
            error_msg = result.stderr.decode()[-500:] if result.stderr else 'Unknown error'
            return jsonify({'success': False, 'error': f'Failed to capture snapshot: {error_msg}'}), 500
            
    except subprocess.TimeoutExpired:
        return jsonify({'success': False, 'error': 'Capture timeout'}), 500
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/video/preview/status')
def api_video_preview_status():
    """Check if preview is available and which source will be used."""
    config = load_config()
    device = config.get('VIDEO_DEVICE', '/dev/video0')
    
    # Check if device exists
    device_exists = os.path.exists(device)
    
    # Check RTSP service status
    rtsp_running = get_service_status() == 'active'
    
    # Determine which source will be used
    # If RTSP is running, camera is busy so we must use RTSP
    source = 'rtsp' if rtsp_running else 'camera'
    
    return jsonify({
        'success': True,
        'camera_available': device_exists,
        'rtsp_running': rtsp_running,
        'device': device,
        'preview_source': source,
        'preview_available': device_exists or rtsp_running
    })


# ============================================================================
# System Configuration API Endpoints
# ============================================================================

@app.route('/api/wifi/scan', methods=['GET'])
def api_wifi_scan():
    """API endpoint to scan for WiFi networks."""
    networks = get_wifi_networks()
    return jsonify({'success': True, 'networks': networks})


@app.route('/api/wifi/status', methods=['GET'])
def api_wifi_status():
    """API endpoint to get WiFi status."""
    info = get_current_wifi()
    config = get_wifi_config()
    return jsonify({
        'success': True,
        'current': info,
        'config': config
    })


@app.route('/api/wifi/connect', methods=['POST'])
def api_wifi_connect():
    """API endpoint to connect to WiFi."""
    try:
        data = request.get_json()
        ssid = data.get('ssid', '')
        password = data.get('password', '')
        is_fallback = data.get('fallback', False)
        
        if not ssid:
            return jsonify({'success': False, 'message': 'SSID required'}), 400
        
        # Fallback network gets lower priority
        priority = 5 if is_fallback else 10
        success, message = connect_wifi(ssid, password, priority)
        
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/wifi/disconnect', methods=['POST'])
def api_wifi_disconnect():
    """API endpoint to disconnect from WiFi."""
    try:
        data = request.get_json()
        ssid = data.get('ssid', '')
        
        if NETWORK_MANAGER_AVAILABLE:
            if ssid:
                subprocess.run(['sudo', 'nmcli', 'con', 'delete', ssid],
                             capture_output=True, timeout=30)
            else:
                subprocess.run(['sudo', 'nmcli', 'dev', 'disconnect', 'wlan0'],
                             capture_output=True, timeout=30)
        return jsonify({'success': True, 'message': 'Disconnected'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# Network Interface API Endpoints
# ============================================================================

@app.route('/api/network/interfaces', methods=['GET'])
def api_network_interfaces():
    """API endpoint to get all network interfaces."""
    interfaces = get_network_interfaces()
    priority = get_interface_priority()
    return jsonify({
        'success': True,
        'interfaces': interfaces,
        'priority': priority
    })


@app.route('/api/network/config', methods=['GET'])
def api_network_config():
    """API endpoint to get network configuration."""
    config = get_network_config()
    return jsonify({'success': True, 'config': config})


@app.route('/api/network/priority', methods=['POST'])
def api_network_priority():
    """API endpoint to set interface priority order."""
    try:
        data = request.get_json()
        interfaces_order = data.get('interfaces', [])
        
        if not interfaces_order:
            return jsonify({'success': False, 'message': 'Interfaces list required'}), 400
        
        success, message = set_interface_priority(interfaces_order)
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/network/static', methods=['POST'])
def api_network_static():
    """API endpoint to configure static IP."""
    try:
        data = request.get_json()
        interface = data.get('interface', '')
        ip_address = data.get('ip', '')
        gateway = data.get('gateway', '')
        dns = data.get('dns', '8.8.8.8')
        
        if not interface or not ip_address or not gateway:
            return jsonify({'success': False, 'message': 'Interface, IP and gateway required'}), 400
        
        success, message = configure_static_ip(interface, ip_address, gateway, dns)
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/network/dhcp', methods=['POST'])
def api_network_dhcp():
    """API endpoint to configure DHCP."""
    try:
        data = request.get_json()
        interface = data.get('interface', '')
        
        if not interface:
            return jsonify({'success': False, 'message': 'Interface required'}), 400
        
        success, message = configure_dhcp(interface)
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# WiFi Failover API Endpoints
# ============================================================================

@app.route('/api/wifi/failover/status', methods=['GET'])
def api_wifi_failover_status():
    """Get WiFi failover status."""
    status = get_wifi_failover_status()
    return jsonify({'success': True, 'status': status})


@app.route('/api/wifi/failover/config', methods=['GET'])
def api_wifi_failover_config_get():
    """Get WiFi failover configuration."""
    config = load_wifi_failover_config()
    return jsonify({'success': True, 'config': config})


@app.route('/api/wifi/failover/config', methods=['POST'])
def api_wifi_failover_config_set():
    """Update WiFi failover configuration."""
    try:
        data = request.get_json()
        config = load_wifi_failover_config()
        
        # Update allowed fields (new dual-failover format)
        allowed_fields = [
            # Hardware failover
            'hardware_failover_enabled', 'primary_interface', 'secondary_interface',
            # Network failover
            'network_failover_enabled', 'primary_ssid',
            'secondary_ssid',
            # IP config
            'ip_mode', 'static_ip', 'gateway', 'dns'
        ]
        for field in allowed_fields:
            if field in data:
                config[field] = data[field]
        
        # Handle passwords separately - only update if not empty
        # This prevents overwriting existing passwords when user leaves field blank
        if data.get('primary_password'):
            config['primary_password'] = data['primary_password']
        if data.get('secondary_password'):
            config['secondary_password'] = data['secondary_password']
        
        if save_wifi_failover_config(config):
            return jsonify({'success': True, 'message': 'Configuration saved'})
        return jsonify({'success': False, 'message': 'Failed to save configuration'}), 500
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/wifi/failover/apply', methods=['POST'])
def api_wifi_failover_apply():
    """Apply WiFi failover - connect the appropriate interface."""
    try:
        result = perform_wifi_failover()
        return jsonify({
            'success': True,
            'result': result
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/wifi/failover/interfaces', methods=['GET'])
def api_wifi_failover_interfaces():
    """Get all WiFi interfaces with their status."""
    interfaces = get_wifi_interfaces()
    return jsonify({'success': True, 'interfaces': interfaces})


@app.route('/api/wifi/failover/disconnect', methods=['POST'])
def api_wifi_failover_disconnect():
    """Disconnect a specific WiFi interface."""
    try:
        data = request.get_json()
        interface = data.get('interface', '')
        
        if not interface:
            return jsonify({'success': False, 'message': 'Interface required'}), 400
        
        success, message = disconnect_wifi_interface(interface)
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# Access Point (AP) Mode API Endpoints
# ============================================================================

AP_CONFIG_FILE = '/etc/rpi-cam/ap_mode.json'

def load_ap_config():
    """Load Access Point configuration."""
    default_config = {
        'ap_enabled': False,
        'ap_interface': 'wlan0',
        'ap_ssid': '',
        'ap_password': '',
        'ap_channel': 7,
        'ap_ip': '192.168.4.1',
        'dhcp_range_start': '192.168.4.10',
        'dhcp_range_end': '192.168.4.100',
        'dhcp_lease_time': '24h'
    }
    try:
        if os.path.exists(AP_CONFIG_FILE):
            with open(AP_CONFIG_FILE, 'r') as f:
                config = json.load(f)
                # Merge with defaults
                return {**default_config, **config}
    except Exception as e:
        print(f"[AP] Error loading config: {e}")
    return default_config


def save_ap_config(config):
    """Save Access Point configuration."""
    try:
        os.makedirs(os.path.dirname(AP_CONFIG_FILE), exist_ok=True)
        with open(AP_CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
        return True
    except Exception as e:
        print(f"[AP] Error saving config: {e}")
        return False


def get_ap_status():
    """Get current Access Point status."""
    status = {
        'enabled': False,
        'active': False,
        'interface': 'wlan0',
        'ssid': '',
        'clients': 0,
        'ip': ''
    }
    
    try:
        # Check if hostapd is running
        result = subprocess.run(['systemctl', 'is-active', 'hostapd'],
                               capture_output=True, text=True, timeout=5)
        status['active'] = result.stdout.strip() == 'active'
        
        if status['active']:
            # Get AP info from hostapd
            config = load_ap_config()
            status['enabled'] = config.get('ap_enabled', False)
            status['interface'] = config.get('ap_interface', 'wlan0')
            status['ssid'] = config.get('ap_ssid', '')
            status['ip'] = config.get('ap_ip', '192.168.4.1')
            
            # Count connected clients
            try:
                result = subprocess.run(['hostapd_cli', '-i', status['interface'], 'all_sta'],
                                       capture_output=True, text=True, timeout=5)
                # Count MAC addresses in output
                status['clients'] = len(re.findall(r'([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}', result.stdout))
            except:
                pass
        else:
            config = load_ap_config()
            status['enabled'] = config.get('ap_enabled', False)
            status['ssid'] = config.get('ap_ssid', '')
    except Exception as e:
        print(f"[AP] Error getting status: {e}")
    
    return status


def configure_hostapd(config):
    """Configure hostapd for Access Point mode."""
    hostapd_conf = f"""# hostapd configuration - Generated by RTSP Recorder
interface={config.get('ap_interface', 'wlan0')}
driver=nl80211
ssid={config.get('ap_ssid', 'RTSP-Device')}
hw_mode=g
channel={config.get('ap_channel', 7)}
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase={config.get('ap_password', '12345678')}
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
"""
    try:
        with open('/tmp/hostapd.conf', 'w') as f:
            f.write(hostapd_conf)
        subprocess.run(['sudo', 'cp', '/tmp/hostapd.conf', '/etc/hostapd/hostapd.conf'],
                      check=True, timeout=5)
        
        # Configure hostapd to use this config
        subprocess.run(['sudo', 'sed', '-i', 's|^#DAEMON_CONF=.*|DAEMON_CONF="/etc/hostapd/hostapd.conf"|',
                       '/etc/default/hostapd'], capture_output=True, timeout=5)
        
        return True, "hostapd configured"
    except Exception as e:
        return False, f"Error configuring hostapd: {e}"


def configure_dnsmasq(config):
    """Configure dnsmasq for DHCP server in AP mode."""
    interface = config.get('ap_interface', 'wlan0')
    ap_ip = config.get('ap_ip', '192.168.4.1')
    dhcp_start = config.get('dhcp_range_start', '192.168.4.10')
    dhcp_end = config.get('dhcp_range_end', '192.168.4.100')
    lease_time = config.get('dhcp_lease_time', '24h')
    
    dnsmasq_conf = f"""# dnsmasq AP configuration - Generated by RTSP Recorder
interface={interface}
bind-interfaces
dhcp-range={dhcp_start},{dhcp_end},{lease_time}
dhcp-option=3,{ap_ip}
dhcp-option=6,{ap_ip}
server=8.8.8.8
server=8.8.4.4
log-facility=/var/log/rpi-cam/dnsmasq.log
log-dhcp
"""
    try:
        with open('/tmp/dnsmasq-ap.conf', 'w') as f:
            f.write(dnsmasq_conf)
        subprocess.run(['sudo', 'cp', '/tmp/dnsmasq-ap.conf', '/etc/dnsmasq.d/rpi-cam-ap.conf'],
                      check=True, timeout=5)
        return True, "dnsmasq configured"
    except Exception as e:
        return False, f"Error configuring dnsmasq: {e}"


def start_access_point():
    """Start Access Point mode."""
    config = load_ap_config()
    interface = config.get('ap_interface', 'wlan0')
    ap_ip = config.get('ap_ip', '192.168.4.1')
    
    try:
        # 1. Stop any WiFi connection on wlan0
        print(f"[AP] Stopping WiFi on {interface}...")
        subprocess.run(['sudo', 'nmcli', 'device', 'disconnect', interface],
                      capture_output=True, timeout=10)
        subprocess.run(['sudo', 'nmcli', 'radio', 'wifi', 'off'],
                      capture_output=True, timeout=5)
        time.sleep(1)
        subprocess.run(['sudo', 'nmcli', 'radio', 'wifi', 'on'],
                      capture_output=True, timeout=5)
        
        # 2. Configure static IP for AP interface
        print(f"[AP] Setting IP {ap_ip} on {interface}...")
        subprocess.run(['sudo', 'ip', 'addr', 'flush', 'dev', interface],
                      capture_output=True, timeout=5)
        subprocess.run(['sudo', 'ip', 'addr', 'add', f'{ap_ip}/24', 'dev', interface],
                      capture_output=True, timeout=5)
        subprocess.run(['sudo', 'ip', 'link', 'set', interface, 'up'],
                      capture_output=True, timeout=5)
        
        # 3. Configure and start hostapd
        print("[AP] Configuring hostapd...")
        success, msg = configure_hostapd(config)
        if not success:
            return False, msg
        
        # 4. Configure and restart dnsmasq
        print("[AP] Configuring dnsmasq...")
        success, msg = configure_dnsmasq(config)
        if not success:
            return False, msg
        
        # 5. Enable IP forwarding (for potential internet sharing)
        subprocess.run(['sudo', 'sysctl', '-w', 'net.ipv4.ip_forward=1'],
                      capture_output=True, timeout=5)
        
        # 6. Start services
        print("[AP] Starting hostapd and dnsmasq...")
        subprocess.run(['sudo', 'systemctl', 'unmask', 'hostapd'], capture_output=True, timeout=5)
        subprocess.run(['sudo', 'systemctl', 'restart', 'hostapd'], capture_output=True, timeout=10)
        subprocess.run(['sudo', 'systemctl', 'restart', 'dnsmasq'], capture_output=True, timeout=10)
        
        # Check if started
        time.sleep(2)
        result = subprocess.run(['systemctl', 'is-active', 'hostapd'],
                               capture_output=True, text=True, timeout=5)
        if result.stdout.strip() == 'active':
            config['ap_enabled'] = True
            save_ap_config(config)
            print(f"[AP] Access Point started: SSID={config.get('ap_ssid')}, IP={ap_ip}")
            return True, f"Access Point démarré: {config.get('ap_ssid')}"
        else:
            # Get error from journal
            err = subprocess.run(['sudo', 'journalctl', '-u', 'hostapd', '-n', '5', '--no-pager'],
                                capture_output=True, text=True, timeout=5)
            return False, f"hostapd failed to start: {err.stdout}"
            
    except Exception as e:
        return False, f"Error starting AP: {e}"


def stop_access_point():
    """Stop Access Point mode."""
    config = load_ap_config()
    interface = config.get('ap_interface', 'wlan0')
    
    try:
        print("[AP] Stopping Access Point...")
        
        # Stop services
        subprocess.run(['sudo', 'systemctl', 'stop', 'hostapd'], capture_output=True, timeout=10)
        
        # Remove dnsmasq AP config
        subprocess.run(['sudo', 'rm', '-f', '/etc/dnsmasq.d/rpi-cam-ap.conf'],
                      capture_output=True, timeout=5)
        subprocess.run(['sudo', 'systemctl', 'restart', 'dnsmasq'], capture_output=True, timeout=10)
        
        # Restore interface for NetworkManager
        subprocess.run(['sudo', 'ip', 'addr', 'flush', 'dev', interface],
                      capture_output=True, timeout=5)
        
        config['ap_enabled'] = False
        save_ap_config(config)
        
        print("[AP] Access Point stopped")
        return True, "Access Point arrêté"
        
    except Exception as e:
        return False, f"Error stopping AP: {e}"


@app.route('/api/network/ap/status', methods=['GET'])
def api_ap_status():
    """Get Access Point status."""
    status = get_ap_status()
    config = load_ap_config()
    return jsonify({
        'success': True,
        'status': status,
        'config': config
    })


@app.route('/api/network/ap/config', methods=['POST'])
def api_ap_config():
    """Configure Access Point settings."""
    try:
        data = request.get_json(force=True, silent=True) or {}
        config = load_ap_config()
        
        # Force channel 11 (fixed)
        config['ap_channel'] = 11
        
        # Update config from Meeting if provided
        if data.get('from_meeting'):
            # Get AP info from Meeting device info
            try:
                result = meeting_api_request('GET', '/devices/{device_key}')
                print(f"[AP Config] Meeting API result: {result}")
                if result.get('success') and result.get('data'):
                    raw_data = result['data']
                    ap_ssid = raw_data.get('ap_ssid', '')
                    ap_password = raw_data.get('ap_password', '')
                    
                    if ap_ssid:
                        config['ap_ssid'] = ap_ssid
                    if ap_password:
                        config['ap_password'] = ap_password
                    
                    if ap_ssid or ap_password:
                        save_ap_config(config)
                        return jsonify({
                            'success': True, 
                            'message': 'Configuration AP récupérée depuis Meeting',
                            'config': config
                        })
                    else:
                        return jsonify({
                            'success': False, 
                            'message': 'Pas de paramètres AP configurés dans Meeting'
                        }), 404
                else:
                    error_msg = result.get('error', 'Erreur inconnue')
                    return jsonify({'success': False, 'message': f'Erreur API Meeting: {error_msg}'}), 500
            except Exception as e:
                return jsonify({'success': False, 'message': f'Erreur Meeting: {e}'}), 500
        else:
            # Update from request (limited fields - Meeting controls most)
            for field in ['ap_ssid', 'ap_password']:
                if field in data:
                    config[field] = data[field]
        
        if save_ap_config(config):
            return jsonify({'success': True, 'message': 'Configuration AP enregistrée', 'config': config})
        return jsonify({'success': False, 'message': 'Erreur sauvegarde'}), 500
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/network/ap/start', methods=['POST'])
def api_ap_start():
    """Start Access Point."""
    try:
        success, message = start_access_point()
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/network/ap/stop', methods=['POST'])
def api_ap_stop():
    """Stop Access Point."""
    try:
        success, message = stop_access_point()
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# WiFi Auto-disable when Ethernet connected
# ============================================================================

def get_ethernet_status():
    """Check if Ethernet is connected and functional."""
    try:
        result = subprocess.run(['ip', '-j', 'link', 'show', 'eth0'],
                               capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            data = json.loads(result.stdout)
            if data and len(data) > 0:
                state = data[0].get('operstate', 'unknown')
                return {
                    'present': True,
                    'connected': state.lower() == 'up',
                    'state': state
                }
    except:
        pass
    return {'present': False, 'connected': False, 'state': 'unknown'}


def get_wifi_manual_override():
    """Check if WiFi manual override is enabled."""
    config = load_config()
    return config.get('WIFI_MANUAL_OVERRIDE', 'no') == 'yes'


def set_wifi_manual_override(enabled):
    """Set WiFi manual override."""
    config = load_config()
    config['WIFI_MANUAL_OVERRIDE'] = 'yes' if enabled else 'no'
    save_config(config)


def manage_wifi_based_on_ethernet():
    """Enable/disable WiFi based on Ethernet status and manual override."""
    eth_status = get_ethernet_status()
    manual_override = get_wifi_manual_override()
    ap_config = load_ap_config()
    ap_enabled = ap_config.get('ap_enabled', False)
    
    # Don't touch wlan0 if AP mode is active
    if ap_enabled:
        print("[Network] AP mode active, skipping WiFi management for wlan0")
        return
    
    if eth_status['connected'] and not manual_override:
        # Ethernet connected and no manual override -> disable WiFi (except wlan1 for fallback)
        print("[Network] Ethernet connected, disabling wlan0...")
        try:
            subprocess.run(['sudo', 'nmcli', 'device', 'disconnect', 'wlan0'],
                          capture_output=True, timeout=10)
        except:
            pass
    elif manual_override or not eth_status['connected']:
        # Manual override or no Ethernet -> WiFi allowed
        print("[Network] WiFi enabled (manual override or no Ethernet)")


def get_wlan0_status():
    """Get wlan0 interface status."""
    status = {
        'present': False,
        'connected': False,
        'managed': False,  # True if auto-disabled because eth is up
        'ap_mode': False
    }
    
    try:
        # Check if in AP mode
        ap_config = load_ap_config()
        if ap_config.get('ap_enabled', False):
            result = subprocess.run(['systemctl', 'is-active', 'hostapd'],
                                   capture_output=True, text=True, timeout=5)
            if result.stdout.strip() == 'active':
                status['present'] = True
                status['ap_mode'] = True
                return status
        
        # Check wlan0 status via nmcli
        result = subprocess.run(['nmcli', '-t', '-f', 'DEVICE,STATE', 'device'],
                               capture_output=True, text=True, timeout=5)
        for line in result.stdout.strip().split('\n'):
            if line.startswith('wlan0:'):
                status['present'] = True
                state = line.split(':')[1] if ':' in line else ''
                status['connected'] = state == 'connected'
                status['managed'] = state == 'disconnected'
                break
    except Exception as e:
        print(f"[Network] Error getting wlan0 status: {e}")
    
    return status


@app.route('/api/network/wifi/override', methods=['GET'])
def api_wifi_override_get():
    """Get WiFi manual override status."""
    override = get_wifi_manual_override()
    eth_status = get_ethernet_status()
    wlan0_status = get_wlan0_status()
    return jsonify({
        'success': True,
        'override': override,
        'ethernet': eth_status,
        'wlan0': wlan0_status
    })


@app.route('/api/network/wifi/override', methods=['POST'])
def api_wifi_override_set():
    """Set WiFi manual override."""
    try:
        data = request.get_json()
        enabled = data.get('enabled', False)
        set_wifi_manual_override(enabled)
        
        # Apply change
        manage_wifi_based_on_ethernet()
        
        return jsonify({
            'success': True,
            'message': 'WiFi activé manuellement' if enabled else 'WiFi géré automatiquement',
            'override': enabled
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/wifi/failover/watchdog', methods=['GET'])
def api_wifi_failover_watchdog_status():
    """Get WiFi failover watchdog status."""
    with wifi_failover_lock:
        running = wifi_failover_state.get('watchdog_running', False)
        last_check = wifi_failover_state.get('last_check')
    return jsonify({
        'success': True,
        'running': running,
        'last_check': last_check
    })


@app.route('/api/wifi/failover/watchdog', methods=['POST'])
def api_wifi_failover_watchdog_control():
    """Start or stop the WiFi failover watchdog."""
    try:
        data = request.get_json()
        action = data.get('action', '')
        
        if action == 'start':
            start_wifi_failover_watchdog()
            return jsonify({'success': True, 'message': 'Watchdog started'})
        elif action == 'stop':
            stop_wifi_failover_watchdog()
            return jsonify({'success': True, 'message': 'Watchdog stopped'})
        else:
            return jsonify({'success': False, 'message': 'Invalid action. Use start or stop'}), 400
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# RTSP Watchdog API
# ============================================================================

@app.route('/api/rtsp/watchdog/status', methods=['GET'])
def api_rtsp_watchdog_status():
    """Get RTSP watchdog status including camera health."""
    with rtsp_watchdog_lock:
        state = rtsp_watchdog_state.copy()
    
    # Add current health check
    healthy, reason = check_rtsp_service_health()
    camera = find_camera_device()
    
    return jsonify({
        'success': True,
        'watchdog': {
            'running': state.get('running', False),
            'last_check': state.get('last_check'),
            'last_healthy': state.get('last_healthy'),
            'restart_count': state.get('restart_count', 0),
            'last_restart': state.get('last_restart')
        },
        'health': {
            'healthy': healthy,
            'reason': reason,
            'camera_device': camera
        }
    })


@app.route('/api/rtsp/watchdog', methods=['POST'])
def api_rtsp_watchdog_control():
    """Control RTSP watchdog."""
    try:
        data = request.get_json()
        action = data.get('action', '')
        
        if action == 'start':
            start_rtsp_watchdog()
            return jsonify({'success': True, 'message': 'RTSP Watchdog started'})
        elif action == 'stop':
            stop_rtsp_watchdog()
            return jsonify({'success': True, 'message': 'RTSP Watchdog stopped'})
        elif action == 'restart_service':
            # Force restart of RTSP service
            restart_rtsp_service("Manual restart requested")
            return jsonify({'success': True, 'message': 'RTSP service restarted'})
        else:
            return jsonify({'success': False, 'message': 'Invalid action. Use start, stop, or restart_service'}), 400
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/leds/status', methods=['GET'])
def api_leds_status():
    """API endpoint to get LED status."""
    leds = get_led_status()
    return jsonify({'success': True, 'leds': leds, 'available': PLATFORM['has_led_control']})


@app.route('/api/leds/set', methods=['POST'])
def api_leds_set():
    """API endpoint to set LED state."""
    try:
        data = request.get_json()
        led = data.get('led', '')  # 'pwr' or 'act'
        enabled = data.get('enabled', True)
        trigger = data.get('trigger', None)
        persist = data.get('persist', False)
        
        if led not in ['pwr', 'act']:
            return jsonify({'success': False, 'message': 'Invalid LED'}), 400
        
        # Set immediate state
        success, message = set_led_state(led, enabled, trigger)
        
        # Always persist to boot config by default (persist=true unless explicitly false)
        persist = data.get('persist', True)  # Default to True for persistence
        
        if persist and success:
            # Get current boot config to preserve the other LED's setting
            boot_config = get_led_boot_config()
            pwr_enabled = enabled if led == 'pwr' else boot_config.get('pwr_enabled', True)
            act_enabled = enabled if led == 'act' else boot_config.get('act_enabled', True)
            
            boot_success, boot_msg = configure_leds_boot(pwr_enabled, act_enabled)
            if boot_success:
                message += " - Configuration persistante au redémarrage activée"
            else:
                message += f" - Attention: persistance échouée ({boot_msg})"
        
        return jsonify({
            'success': success, 
            'message': message,
            'persisted': persist,
            'reboot_required': persist  # Indicate reboot is needed for full effect
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/leds/boot-config', methods=['GET'])
def api_leds_boot_config():
    """API endpoint to get LED boot configuration."""
    boot_config = get_led_boot_config()
    return jsonify({
        'success': True, 
        'boot_config': boot_config,
        'config_file': BOOT_CONFIG_FILE
    })


@app.route('/api/gpu/mem', methods=['GET'])
def api_gpu_mem_get():
    """API endpoint to get GPU memory."""
    mem = get_gpu_mem()
    return jsonify({'success': True, 'gpu_mem': mem, 'available': True})


@app.route('/api/gpu/mem', methods=['POST'])
def api_gpu_mem_set():
    """API endpoint to set GPU memory."""
    try:
        data = request.get_json()
        mem_mb = data.get('gpu_mem', 128)
        
        success, message = set_gpu_mem(mem_mb)
        return jsonify({'success': success, 'message': message})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# Power Management API (Energy Saving)
# ============================================================================

@app.route('/api/power/status', methods=['GET'])
def api_power_status():
    """API endpoint to get power/energy status of all components."""
    power_status = get_power_status()
    boot_config = get_boot_power_config()
    
    return jsonify({
        'success': True,
        'current': power_status,
        'boot_config': boot_config,
        'config_file': BOOT_CONFIG_FILE
    })


@app.route('/api/power/bluetooth', methods=['POST'])
def api_power_bluetooth():
    """API endpoint to control Bluetooth."""
    try:
        data = request.get_json()
        enabled = data.get('enabled', True)
        persist = data.get('persist', True)
        
        # Try to set immediately
        success, message = set_bluetooth_state(enabled)
        
        if persist and success:
            # Get current boot config and update
            boot_config = get_boot_power_config()
            hdmi_enabled = boot_config.get('hdmi_enabled', True)
            audio_enabled = boot_config.get('audio_enabled', True)
            
            boot_success, boot_msg = configure_power_boot(enabled, hdmi_enabled, audio_enabled)
            if boot_success:
                message += " - Configuration persistante au redémarrage activée"
            else:
                message += f" - Attention: persistance échouée ({boot_msg})"
        
        return jsonify({
            'success': success,
            'message': message,
            'persisted': persist,
            'reboot_required': persist
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/power/hdmi', methods=['POST'])
def api_power_hdmi():
    """API endpoint to control HDMI."""
    try:
        data = request.get_json()
        enabled = data.get('enabled', True)
        persist = data.get('persist', True)
        
        if persist:
            # Get current boot config and update
            boot_config = get_boot_power_config()
            bt_enabled = boot_config.get('bluetooth_enabled', True)
            audio_enabled = boot_config.get('audio_enabled', True)
            
            success, message = configure_power_boot(bt_enabled, enabled, audio_enabled)
            if success:
                message = f"HDMI {'activé' if enabled else 'désactivé'} - " + message
            
            return jsonify({
                'success': success,
                'message': message,
                'persisted': persist,
                'reboot_required': persist
            })
        else:
            return jsonify({
                'success': False,
                'message': 'Runtime HDMI control not available. Use boot config.'
            })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/power/audio', methods=['POST'])
def api_power_audio():
    """API endpoint to control Audio."""
    try:
        data = request.get_json()
        enabled = data.get('enabled', True)
        persist = data.get('persist', True)
        
        if persist:
            # Get current boot config and update
            boot_config = get_boot_power_config()
            bt_enabled = boot_config.get('bluetooth_enabled', True)
            hdmi_enabled = boot_config.get('hdmi_enabled', True)
            
            success, message = configure_power_boot(bt_enabled, hdmi_enabled, enabled)
            if success:
                message = f"Audio {'activé' if enabled else 'désactivé'} - " + message
            
            return jsonify({
                'success': success,
                'message': message,
                'persisted': persist,
                'reboot_required': persist
            })
        else:
            return jsonify({
                'success': False,
                'message': 'Runtime audio control not available. Use boot config.'
            })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/power/cpu-freq', methods=['POST'])
def api_power_cpu_freq():
    """API endpoint to control CPU frequency."""
    try:
        data = request.get_json()
        freq_mhz = data.get('freq_mhz', 1200)
        
        success, message = set_cpu_frequency(freq_mhz)
        
        return jsonify({
            'success': success,
            'message': message,
            'reboot_required': False  # CPU freq change takes effect immediately
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/power/boot-config', methods=['GET'])
def api_power_boot_config():
    """API endpoint to get power boot configuration."""
    boot_config = get_boot_power_config()
    services_status = get_all_services_status()
    return jsonify({
        'success': True,
        'boot_config': boot_config,
        'services': services_status,
        'config_file': BOOT_CONFIG_FILE
    })


@app.route('/api/power/apply-all', methods=['POST'])
def api_power_apply_all():
    """API endpoint to apply all power settings at once."""
    try:
        data = request.get_json()
        
        # Get all settings from request
        led_pwr = data.get('led_pwr', True)
        led_act = data.get('led_act', True)
        led_camera_csi = data.get('led_camera_csi', True)
        bluetooth = data.get('bluetooth', True)
        wifi = data.get('wifi', True)
        hdmi = data.get('hdmi', True)
        audio = data.get('audio', True)
        
        # Service settings
        service_modemmanager = data.get('service_modemmanager', True)
        service_avahi = data.get('service_avahi', True)
        service_cloudinit = data.get('service_cloudinit', True)
        service_serial = data.get('service_serial', True)
        service_tty1 = data.get('service_tty1', True)
        service_udisks2 = data.get('service_udisks2', True)
        
        errors = []
        
        # Apply all settings to boot config
        success, message = configure_power_boot(
            bluetooth_enabled=bluetooth,
            hdmi_enabled=hdmi,
            audio_enabled=audio,
            wifi_enabled=wifi,
            pwr_led_enabled=led_pwr,
            act_led_enabled=led_act,
            camera_led_csi_enabled=led_camera_csi
        )
        
        if not success:
            errors.append(f"Boot config: {message}")
        
        # Apply service settings
        service_settings = [
            ('modemmanager', service_modemmanager),
            ('avahi', service_avahi),
            ('cloudinit', service_cloudinit),
            ('serial', service_serial),
            ('tty1', service_tty1),
            ('udisks2', service_udisks2)
        ]
        
        for service_key, enabled in service_settings:
            svc_success, svc_message = set_service_state(service_key, enabled)
            if not svc_success:
                errors.append(f"{service_key}: {svc_message}")
        
        # Calculate estimated savings
        savings = 0
        if not bluetooth:
            savings += 20
        if not wifi:
            savings += 40
        if not hdmi:
            savings += 40
        if not audio:
            savings += 10
        if not led_pwr:
            savings += 5
        if not led_act:
            savings += 3
        if not led_camera_csi:
            savings += 2
        # Service savings
        if not service_modemmanager:
            savings += 15
        if not service_avahi:
            savings += 5
        if not service_serial:
            savings += 2
        if not service_tty1:
            savings += 2
        if not service_udisks2:
            savings += 5
        
        if errors:
            return jsonify({
                'success': False,
                'message': 'Certains paramètres ont échoué: ' + '; '.join(errors),
                'partial_errors': errors,
                'estimated_savings_ma': savings
            }), 500
        
        return jsonify({
            'success': True,
            'message': 'Tous les paramètres ont été enregistrés. Redémarrage requis pour les changements hardware.',
            'estimated_savings_ma': savings,
            'reboot_required': True
        })
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/system/reboot', methods=['POST'])
def api_system_reboot():
    """API endpoint to reboot the system."""
    try:
        subprocess.Popen(['sudo', 'reboot'], 
                        stdout=subprocess.DEVNULL, 
                        stderr=subprocess.DEVNULL)
        return jsonify({'success': True, 'message': 'Rebooting...'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# NTP Configuration API
# ============================================================================

@app.route('/api/system/ntp', methods=['GET'])
def api_ntp_get():
    """Get NTP configuration and status."""
    try:
        result = {
            'success': True,
            'server': '',
            'synchronized': False,
            'current_time': '',
            'timezone': ''
        }
        
        # Get current NTP server from timesyncd
        try:
            with open('/etc/systemd/timesyncd.conf', 'r') as f:
                for line in f:
                    if line.strip().startswith('NTP='):
                        result['server'] = line.split('=', 1)[1].strip()
                        break
        except:
            pass
        
        # Fallback: check timedatectl
        if not result['server']:
            try:
                output = subprocess.run(
                    ['timedatectl', 'show', '--property=NTP', '--value'],
                    capture_output=True, text=True, timeout=5
                )
                if output.returncode == 0 and output.stdout.strip() == 'yes':
                    result['server'] = 'pool.ntp.org'  # Default
            except:
                pass
        
        # Get sync status
        try:
            output = subprocess.run(
                ['timedatectl', 'show', '--property=NTPSynchronized', '--value'],
                capture_output=True, text=True, timeout=5
            )
            result['synchronized'] = output.stdout.strip().lower() == 'yes'
        except:
            pass
        
        # Get current time
        try:
            output = subprocess.run(
                ['date', '+%Y-%m-%d %H:%M:%S'],
                capture_output=True, text=True, timeout=5
            )
            result['current_time'] = output.stdout.strip()
        except:
            pass
        
        # Get timezone
        try:
            output = subprocess.run(
                ['timedatectl', 'show', '--property=Timezone', '--value'],
                capture_output=True, text=True, timeout=5
            )
            result['timezone'] = output.stdout.strip()
        except:
            pass
        
        return jsonify(result)
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/system/ntp', methods=['POST'])
def api_ntp_set():
    """Set NTP server configuration."""
    try:
        data = request.get_json()
        server = data.get('server', '').strip()
        
        if not server:
            return jsonify({'success': False, 'message': 'Serveur NTP requis'}), 400
        
        # Update /etc/systemd/timesyncd.conf
        config_content = f"""[Time]
NTP={server}
FallbackNTP=pool.ntp.org time.google.com
"""
        
        # Write config
        result = subprocess.run(
            ['sudo', 'tee', '/etc/systemd/timesyncd.conf'],
            input=config_content, capture_output=True, text=True, timeout=10
        )
        
        if result.returncode != 0:
            return jsonify({'success': False, 'message': f'Erreur écriture config: {result.stderr}'}), 500
        
        # Restart timesyncd
        subprocess.run(['sudo', 'systemctl', 'restart', 'systemd-timesyncd'],
                      capture_output=True, timeout=10)
        
        return jsonify({'success': True, 'message': f'Serveur NTP configuré: {server}'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/system/ntp/sync', methods=['POST'])
def api_ntp_sync():
    """Force NTP synchronization."""
    try:
        # Restart timesyncd to force resync
        result = subprocess.run(
            ['sudo', 'systemctl', 'restart', 'systemd-timesyncd'],
            capture_output=True, text=True, timeout=30
        )
        
        if result.returncode != 0:
            return jsonify({'success': False, 'message': f'Erreur: {result.stderr}'}), 500
        
        # Wait a moment for sync
        time.sleep(2)
        
        # Check if synced
        output = subprocess.run(
            ['timedatectl', 'show', '--property=NTPSynchronized', '--value'],
            capture_output=True, text=True, timeout=5
        )
        synced = output.stdout.strip().lower() == 'yes'
        
        return jsonify({
            'success': True,
            'synchronized': synced,
            'message': 'Synchronisation effectuée' if synced else 'Synchronisation en cours...'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# GitHub Updater API
# ============================================================================

GITHUB_REPO = 'sn8k/RTSP-Full'  # À configurer selon votre repo
APP_VERSION = '2.30.0'

@app.route('/api/system/update/check', methods=['GET'])
def api_update_check():
    """Check for available updates from GitHub."""
    try:
        import urllib.request
        import json
        
        # Get latest release from GitHub API
        url = f'https://api.github.com/repos/{GITHUB_REPO}/releases/latest'
        
        req = urllib.request.Request(url, headers={
            'User-Agent': 'RTSP-Recorder-Updater',
            'Accept': 'application/vnd.github.v3+json'
        })
        
        try:
            with urllib.request.urlopen(req, timeout=10) as response:
                data = json.loads(response.read().decode())
        except urllib.error.HTTPError as e:
            if e.code == 404:
                # No releases yet
                return jsonify({
                    'success': True,
                    'current_version': f'v{APP_VERSION}',
                    'latest_version': f'v{APP_VERSION}',
                    'update_available': False,
                    'message': 'Pas de release disponible sur GitHub'
                })
            raise
        
        latest_tag = data.get('tag_name', '').lstrip('v')
        changelog = data.get('body', '')
        
        # Compare versions
        def version_tuple(v):
            return tuple(map(int, v.split('.')))
        
        try:
            update_available = version_tuple(latest_tag) > version_tuple(APP_VERSION)
        except:
            update_available = latest_tag != APP_VERSION
        
        return jsonify({
            'success': True,
            'current_version': f'v{APP_VERSION}',
            'latest_version': f'v{latest_tag}',
            'update_available': update_available,
            'changelog': changelog,
            'download_url': data.get('zipball_url', '')
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e),
            'current_version': f'v{APP_VERSION}'
        }), 500


@app.route('/api/system/update/perform', methods=['POST'])
def api_update_perform():
    """Perform system update from GitHub."""
    try:
        import tempfile
        import shutil
        
        log_lines = []
        
        def log(msg):
            log_lines.append(msg)
            print(f"[Updater] {msg}")
        
        log("Démarrage de la mise à jour...")
        
        # Check if git is available
        result = subprocess.run(['which', 'git'], capture_output=True)
        if result.returncode != 0:
            return jsonify({
                'success': False,
                'message': 'Git non installé',
                'log': '\\n'.join(log_lines)
            }), 500
        
        # Get installation directory
        install_dir = '/opt/rpi-cam-webmanager'
        
        # Check if it's a git repo
        if os.path.exists(os.path.join(install_dir, '.git')):
            # Git pull
            log("Mise à jour via git pull...")
            result = subprocess.run(
                ['sudo', 'git', '-C', install_dir, 'pull', 'origin', 'main'],
                capture_output=True, text=True, timeout=120
            )
            log(result.stdout if result.stdout else result.stderr)
            
            if result.returncode != 0:
                return jsonify({
                    'success': False,
                    'message': 'Erreur git pull',
                    'log': '\\n'.join(log_lines)
                }), 500
        else:
            # Clone fresh
            log("Clonage du dépôt GitHub...")
            backup_dir = f'/tmp/rpi-cam-backup-{int(time.time())}'
            
            # Backup current installation
            if os.path.exists(install_dir):
                log(f"Sauvegarde vers {backup_dir}...")
                shutil.move(install_dir, backup_dir)
            
            # Clone
            result = subprocess.run(
                ['sudo', 'git', 'clone', f'https://github.com/{GITHUB_REPO}.git', install_dir],
                capture_output=True, text=True, timeout=300
            )
            log(result.stdout if result.stdout else result.stderr)
            
            if result.returncode != 0:
                # Restore backup
                if os.path.exists(backup_dir):
                    shutil.move(backup_dir, install_dir)
                return jsonify({
                    'success': False,
                    'message': 'Erreur lors du clonage',
                    'log': '\\n'.join(log_lines)
                }), 500
            
            # Copy web-manager to installation dir
            log("Installation des fichiers web-manager...")
            web_src = os.path.join(install_dir, 'web-manager')
            if os.path.exists(web_src):
                for item in os.listdir(web_src):
                    src = os.path.join(web_src, item)
                    dst = os.path.join(install_dir, item)
                    if os.path.isdir(src):
                        if os.path.exists(dst):
                            shutil.rmtree(dst)
                        shutil.copytree(src, dst)
                    else:
                        shutil.copy2(src, dst)
        
        log("Redémarrage du service...")
        subprocess.run(['sudo', 'systemctl', 'restart', 'rpi-cam-webmanager'],
                      capture_output=True, timeout=30)
        
        log("Mise à jour terminée avec succès!")
        
        return jsonify({
            'success': True,
            'message': 'Mise à jour terminée! Le service redémarre...',
            'log': '\\n'.join(log_lines)
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500


# ============================================================================
# Debug / Maintenance API
# ============================================================================

def get_pi_model():
    """Detect Raspberry Pi model for firmware update method selection."""
    try:
        with open('/proc/device-tree/model', 'r') as f:
            model = f.read().strip().rstrip('\x00')
            if 'Pi 4' in model or 'Pi 5' in model:
                return 'pi4+'  # Uses rpi-eeprom-update
            elif 'Pi 3' in model or 'Pi 2' in model or 'Pi Zero' in model:
                return 'pi3'   # Uses rpi-update
            else:
                return 'unknown'
    except:
        return 'unknown'


def has_initramfs():
    """Check if system uses initramfs (incompatible with rpi-update)."""
    # Check if initramfs is configured in config.txt or cmdline.txt
    config_files = ['/boot/firmware/config.txt', '/boot/config.txt']
    for cfg in config_files:
        try:
            if os.path.exists(cfg):
                with open(cfg, 'r') as f:
                    content = f.read()
                    if 'initramfs' in content.lower():
                        return True
        except:
            pass
    
    # Check if initramfs images exist (stronger indicator)
    initrd_paths = [
        '/boot/firmware/initrd.img',
        '/boot/initrd.img',
        '/boot/firmware/initramfs'
    ]
    for path in initrd_paths:
        if os.path.exists(path):
            return True
    
    # Check for initramfs in /boot/firmware/ with kernel version pattern
    try:
        import glob
        if glob.glob('/boot/firmware/initrd.img-*') or glob.glob('/boot/initrd.img-*'):
            return True
    except:
        pass
    
    return False


@app.route('/api/debug/firmware/check', methods=['GET'])
def api_debug_firmware_check():
    """Check for Raspberry Pi firmware updates.
    
    Pi 4/5: Uses rpi-eeprom-update to check EEPROM bootloader
    Pi 3/2/Zero: Uses rpi-update with JUST_CHECK=1 to check kernel/firmware
                 BUT: Not supported if initramfs is configured (use apt upgrade instead)
    """
    pi_model = get_pi_model()
    
    try:
        if pi_model == 'pi4+':
            # Pi 4/5: Check EEPROM updates
            result = subprocess.run(
                ['sudo', 'rpi-eeprom-update'],
                capture_output=True, text=True, timeout=30
            )
            
            output = result.stdout + result.stderr
            update_available = 'UPDATE AVAILABLE' in output.upper()
            
            current_version = "Inconnu"
            for line in output.split('\n'):
                if 'CURRENT:' in line or 'current:' in line.lower():
                    current_version = line.split(':')[-1].strip()
                    break
            
            return jsonify({
                'success': True,
                'method': 'rpi-eeprom-update',
                'model': 'Pi 4/5',
                'update_available': update_available,
                'current_version': current_version,
                'output': output,
                'message': 'Mise à jour EEPROM disponible' if update_available else 'EEPROM à jour',
                'can_update': True
            })
        else:
            # Pi 3/2/Zero: Check if initramfs is in use
            if has_initramfs():
                # System uses initramfs - rpi-update is NOT supported
                # Get current kernel version instead
                try:
                    uname_result = subprocess.run(['uname', '-r'], capture_output=True, text=True, timeout=5)
                    kernel_version = uname_result.stdout.strip()
                except:
                    kernel_version = "Inconnu"
                
                return jsonify({
                    'success': True,
                    'method': 'apt',
                    'model': 'Pi 3/2/Zero (initramfs)',
                    'update_available': False,  # We don't know, use apt upgrade
                    'current_version': kernel_version,
                    'output': 'Ce système utilise initramfs, incompatible avec rpi-update.\n'
                              'Utilisez "apt upgrade" dans l\'onglet ci-dessous pour les mises à jour du kernel et firmware.\n'
                              'Les paquets linux-image-* et raspberrypi-kernel fournissent les mises à jour stables.',
                    'message': 'Utilisez apt upgrade pour les mises à jour (initramfs détecté)',
                    'can_update': False,
                    'use_apt': True
                })
            
            # No initramfs - can use rpi-update
            env = os.environ.copy()
            env['JUST_CHECK'] = '1'
            
            result = subprocess.run(
                ['sudo', '-E', 'rpi-update'],
                capture_output=True, text=True, timeout=60,
                env=env
            )
            
            output = result.stdout + result.stderr
            
            # Parse rpi-update output
            update_available = 'update required' in output.lower() or 'running for the first time' in output.lower()
            
            # Extract firmware revision
            current_version = "Inconnu"
            for line in output.split('\n'):
                if 'FW_REV:' in line:
                    current_version = line.split(':')[-1].strip()[:12] + '...'
                    break
            
            return jsonify({
                'success': True,
                'method': 'rpi-update',
                'model': 'Pi 3/2/Zero',
                'update_available': update_available,
                'current_version': current_version,
                'output': output,
                'message': 'Mise à jour firmware disponible' if update_available else 'Firmware à jour',
                'can_update': True
            })
            
    except FileNotFoundError as e:
        return jsonify({
            'success': False,
            'message': f'Outil de mise à jour non trouvé: {str(e)}',
            'output': 'Installez rpi-update ou rpi-eeprom-update selon votre modèle de Pi.'
        })
    except subprocess.TimeoutExpired:
        return jsonify({
            'success': False,
            'message': 'Timeout lors de la vérification',
            'output': 'La vérification a pris trop de temps.'
        }), 500
    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500


@app.route('/api/debug/firmware/update', methods=['POST'])
def api_debug_firmware_update():
    """Apply Raspberry Pi firmware update.
    
    Pi 4/5: Uses rpi-eeprom-update -a
    Pi 3/2/Zero: Uses rpi-update (downloads and installs new kernel/firmware)
    
    WARNING: rpi-update installs bleeding-edge firmware which may be unstable.
    """
    pi_model = get_pi_model()
    
    try:
        if pi_model == 'pi4+':
            # Pi 4/5: Apply EEPROM update
            result = subprocess.run(
                ['sudo', 'rpi-eeprom-update', '-a'],
                capture_output=True, text=True, timeout=300
            )
            
            output = result.stdout + result.stderr
            success = result.returncode == 0
            
            return jsonify({
                'success': success,
                'method': 'rpi-eeprom-update',
                'output': output,
                'message': 'EEPROM mis à jour. Redémarrez pour finaliser.' if success else 'Erreur lors de la mise à jour EEPROM',
                'reboot_required': success
            })
        else:
            # Pi 3/2/Zero: Run rpi-update
            # Note: This downloads ~100MB and takes several minutes
            result = subprocess.run(
                ['sudo', 'rpi-update'],
                capture_output=True, text=True, timeout=600,  # 10 min timeout
                input='y\n'  # Auto-confirm
            )
            
            output = result.stdout + result.stderr
            success = result.returncode == 0 or 'already up to date' in output.lower()
            
            return jsonify({
                'success': success,
                'method': 'rpi-update',
                'output': output,
                'message': 'Firmware mis à jour. Redémarrez pour finaliser.' if success else 'Erreur lors de la mise à jour',
                'reboot_required': success,
                'warning': 'rpi-update installe un firmware expérimental. Utilisez avec précaution.'
            })
            
    except FileNotFoundError as e:
        return jsonify({
            'success': False,
            'message': f'Outil de mise à jour non trouvé: {str(e)}',
            'output': 'Installez rpi-update ou rpi-eeprom-update selon votre modèle de Pi.'
        })
    except subprocess.TimeoutExpired:
        return jsonify({
            'success': False,
            'message': 'Timeout: la mise à jour a pris trop de temps',
            'output': 'La mise à jour n\'a pas pu se terminer dans le temps imparti.'
        }), 500
    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500


@app.route('/api/debug/apt/update', methods=['POST'])
def api_debug_apt_update():
    """Run apt update to refresh package lists."""
    try:
        result = subprocess.run(
            ['sudo', 'apt-get', 'update'],
            capture_output=True, text=True, timeout=300
        )
        
        output = result.stdout + result.stderr
        success = result.returncode == 0
        
        # Count updated/new packages
        hit_count = output.count('Hit:')
        get_count = output.count('Get:')
        
        return jsonify({
            'success': success,
            'output': output,
            'hit_count': hit_count,
            'get_count': get_count,
            'message': f'Terminé: {hit_count} sources vérifiées, {get_count} mises à jour' if success else 'Erreur lors de apt update'
        })
    except subprocess.TimeoutExpired:
        return jsonify({
            'success': False,
            'message': 'Timeout: apt update a pris trop de temps (>5 min)'
        }), 500
    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500


@app.route('/api/debug/apt/upgradable', methods=['GET'])
def api_debug_apt_upgradable():
    """List packages that can be upgraded."""
    try:
        result = subprocess.run(
            ['apt', 'list', '--upgradable'],
            capture_output=True, text=True, timeout=60
        )
        
        output = result.stdout
        lines = [l for l in output.split('\n') if l and 'Listing...' not in l]
        
        packages = []
        for line in lines:
            if '/' in line:
                parts = line.split()
                if parts:
                    pkg_name = parts[0].split('/')[0]
                    pkg_version = parts[1] if len(parts) > 1 else ''
                    packages.append({
                        'name': pkg_name,
                        'version': pkg_version,
                        'line': line
                    })
        
        return jsonify({
            'success': True,
            'packages': packages,
            'count': len(packages),
            'output': output,
            'message': f'{len(packages)} paquets peuvent être mis à jour'
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500


@app.route('/api/debug/apt/upgrade', methods=['POST'])
def api_debug_apt_upgrade():
    """Run apt upgrade to update all packages."""
    try:
        # Use DEBIAN_FRONTEND=noninteractive to avoid prompts
        env = os.environ.copy()
        env['DEBIAN_FRONTEND'] = 'noninteractive'
        
        result = subprocess.run(
            ['sudo', 'apt-get', 'upgrade', '-y'],
            capture_output=True, text=True, timeout=1800,  # 30 min timeout
            env=env
        )
        
        output = result.stdout + result.stderr
        success = result.returncode == 0
        
        # Parse output for stats
        upgraded = 0
        newly_installed = 0
        for line in output.split('\n'):
            if 'upgraded,' in line and 'newly installed' in line:
                parts = line.split()
                try:
                    upgraded = int(parts[0])
                    newly_installed = int(parts[2])
                except:
                    pass
        
        return jsonify({
            'success': success,
            'output': output,
            'upgraded': upgraded,
            'newly_installed': newly_installed,
            'message': f'Terminé: {upgraded} mis à jour, {newly_installed} nouveaux' if success else 'Erreur lors de apt upgrade'
        })
    except subprocess.TimeoutExpired:
        return jsonify({
            'success': False,
            'message': 'Timeout: apt upgrade a pris trop de temps (>30 min)'
        }), 500
    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500


@app.route('/api/debug/system/uptime', methods=['GET'])
def api_debug_system_uptime():
    """Get system uptime."""
    try:
        result = subprocess.run(
            ['uptime', '-p'],
            capture_output=True, text=True, timeout=5
        )
        uptime_pretty = result.stdout.strip()
        
        # Also get uptime in seconds
        with open('/proc/uptime', 'r') as f:
            uptime_seconds = float(f.read().split()[0])
        
        return jsonify({
            'success': True,
            'uptime': uptime_pretty,
            'uptime_seconds': uptime_seconds
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500


# ============================================================================
# Meeting API Integration
# ============================================================================

import urllib.request
import urllib.parse
import urllib.error
import ssl

def get_preferred_ip():
    """Get local IP address based on interface priority.
    
    Priority: eth0 (Ethernet) > wlan1 (USB WiFi) > wlan0 (built-in WiFi)
    Configurable via NETWORK_INTERFACE_PRIORITY in config.env
    """
    import subprocess
    
    # Default priority order - Ethernet first, then WiFi interfaces
    priority_order = ['eth0', 'wlan1', 'wlan0', 'enp0s3', 'end0']
    
    # Try to read custom priority from config file
    try:
        config = load_config()
        custom_priority = config.get('NETWORK_INTERFACE_PRIORITY', '')
        if custom_priority:
            priority_order = [iface.strip() for iface in custom_priority.split(',')]
    except:
        pass
    
    # Get all interface IPs
    interface_ips = {}
    try:
        result = subprocess.run(['ip', '-4', 'addr'], capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            current_iface = None
            for line in result.stdout.split('\n'):
                # Match interface line: "2: eth0: <BROADCAST,MULTICAST,UP,..."
                if ': ' in line and not line.startswith(' '):
                    parts = line.split(': ')
                    if len(parts) >= 2:
                        current_iface = parts[1].split('@')[0]  # Handle eth0@if2 format
                # Match IP line: "    inet 192.168.1.191/24 ..."
                elif current_iface and 'inet ' in line and 'scope global' in line:
                    parts = line.strip().split()
                    if len(parts) >= 2:
                        ip = parts[1].split('/')[0]
                        if not ip.startswith('127.'):
                            interface_ips[current_iface] = ip
    except Exception as e:
        print(f"[get_preferred_ip] Error getting interfaces: {e}")
    
    # Return IP of highest priority interface
    for iface in priority_order:
        if iface in interface_ips:
            return interface_ips[iface]
    
    # Fallback: any non-loopback IP
    for ip in interface_ips.values():
        return ip
    
    # Ultimate fallback: socket method
    return get_local_ip()

def get_local_ip():
    """Get local IP address of the device (fallback method)."""
    try:
        import socket
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "127.0.0.1"

def meeting_api_request(method, endpoint, data=None, config=None):
    """Make a request to the Meeting API."""
    if config is None:
        config = load_config()
    
    api_url = config.get('MEETING_API_URL', '').rstrip('/')
    device_key = config.get('MEETING_DEVICE_KEY', '')
    token_code = config.get('MEETING_TOKEN_CODE', '')
    
    if not api_url or not device_key:
        return {'success': False, 'error': 'Meeting API non configurée (URL ou Device Key manquant)'}
    
    url = f"{api_url}{endpoint}".replace('{device_key}', device_key)
    
    # Prepare headers
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'User-Agent': 'RTSP-Recorder/1.0'
    }
    
    # Add token if available
    if token_code:
        headers['X-Token-Code'] = token_code
    
    try:
        # Create SSL context that doesn't verify (for self-signed certs)
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        
        # Prepare request
        if data:
            body = json.dumps(data).encode('utf-8')
        else:
            body = None
        
        req = urllib.request.Request(url, data=body, headers=headers, method=method)
        
        with urllib.request.urlopen(req, timeout=10, context=ssl_context) as response:
            response_data = response.read().decode('utf-8')
            try:
                return {'success': True, 'data': json.loads(response_data), 'status': response.status}
            except json.JSONDecodeError:
                return {'success': True, 'data': response_data, 'status': response.status}
                
    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else ''
        try:
            error_data = json.loads(error_body)
        except:
            error_data = error_body
        return {'success': False, 'error': f'HTTP {e.code}: {e.reason}', 'details': error_data, 'status': e.code}
    except urllib.error.URLError as e:
        return {'success': False, 'error': f'Erreur de connexion: {str(e.reason)}'}
    except Exception as e:
        return {'success': False, 'error': str(e)}


# ============================================================================
# Meeting Heartbeat Background Thread
# ============================================================================

def get_mac_address():
    """Get MAC address of the primary network interface."""
    try:
        # Try to get MAC from the interface used for default route
        result = subprocess.run(
            ['ip', 'route', 'get', '8.8.8.8'],
            capture_output=True, text=True, timeout=5
        )
        if result.returncode == 0:
            # Extract interface name (e.g., "dev eth0" or "dev wlan0")
            import re
            match = re.search(r'dev\s+(\S+)', result.stdout)
            if match:
                iface = match.group(1)
                # Read MAC from sysfs
                mac_path = f'/sys/class/net/{iface}/address'
                if os.path.exists(mac_path):
                    with open(mac_path, 'r') as f:
                        return f.read().strip().upper()
        
        # Fallback: try common interfaces
        for iface in ['eth0', 'wlan0', 'enp0s3', 'wlan1']:
            mac_path = f'/sys/class/net/{iface}/address'
            if os.path.exists(mac_path):
                with open(mac_path, 'r') as f:
                    mac = f.read().strip()
                    if mac and mac != '00:00:00:00:00:00':
                        return mac.upper()
    except Exception as e:
        print(f"[Meeting] Error getting MAC address: {e}")
    return None


def get_public_ip():
    """Get public IP address of the device."""
    services = [
        'https://api.ipify.org',
        'https://ifconfig.me/ip',
        'https://icanhazip.com',
        'https://checkip.amazonaws.com'
    ]
    
    for service in services:
        try:
            import urllib.request
            import ssl
            
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE
            
            req = urllib.request.Request(service, headers={'User-Agent': 'curl/7.68.0'})
            with urllib.request.urlopen(req, timeout=5, context=ssl_context) as response:
                ip = response.read().decode('utf-8').strip()
                # Validate it looks like an IP
                if ip and '.' in ip and len(ip) <= 15:
                    return ip
        except Exception:
            continue
    return None


def get_cluster_from_api_url(api_url):
    """Extract cluster name from Meeting API URL."""
    if not api_url:
        return None
    try:
        # Extract hostname from URL (e.g., https://clusterTO83.meeting.ygsoft.fr/api -> clusterTO83)
        import re
        match = re.search(r'https?://([^/]+)', api_url)
        if match:
            hostname = match.group(1)
            # If hostname starts with "cluster", extract just that part
            if hostname.lower().startswith('cluster'):
                return hostname.split('.')[0]
            # Otherwise return full hostname without port
            return hostname.split(':')[0]
    except Exception:
        pass
    return None


def build_heartbeat_payload(config):
    """Build the payload for heartbeat request."""
    services = []
    
    # Check RTSP service
    rtsp_port = config.get('RTSP_PORT', '8554')
    services.append({
        'name': 'rtsp',
        'port': int(rtsp_port),
        'protocol': 'tcp'
    })
    
    # Check web manager (always running)
    services.append({
        'name': 'http',
        'port': 5000,
        'protocol': 'tcp'
    })
    
    # Check SSH
    try:
        result = subprocess.run(['systemctl', 'is-active', 'ssh'], 
                              capture_output=True, text=True, timeout=5)
        if result.stdout.strip() == 'active':
            services.append({'name': 'ssh', 'port': 22, 'protocol': 'tcp'})
    except:
        pass
    
    # Build payload with all available information
    payload = {
        'ip': get_local_ip(),
        'services': services,
        'note': f"RTSP Recorder - {PLATFORM['model']}"
    }
    
    # Add MAC address if available
    mac = get_mac_address()
    if mac:
        payload['mac_address'] = mac
    
    # Add public IP if available
    public_ip = get_public_ip()
    if public_ip:
        payload['public_ip'] = public_ip
    
    # Add cluster name from API URL
    api_url = config.get('MEETING_API_URL', '')
    cluster = get_cluster_from_api_url(api_url)
    if cluster:
        payload['cluster'] = cluster
    
    return payload


def send_heartbeat_internal(config=None):
    """Internal function to send heartbeat. Returns (success, error_message)."""
    global meeting_state
    
    if config is None:
        config = load_config()
    
    payload = build_heartbeat_payload(config)
    result = meeting_api_request('POST', '/devices/{device_key}/online', data=payload, config=config)
    
    with meeting_lock:
        if result['success']:
            meeting_state['last_heartbeat'] = time.time()
            meeting_state['last_heartbeat_error'] = None
            meeting_state['connected'] = True
            return True, None
        else:
            meeting_state['last_heartbeat_error'] = result.get('error', 'Unknown error')
            meeting_state['connected'] = False
            return False, result.get('error', 'Unknown error')


def heartbeat_loop():
    """Background thread that sends heartbeats at regular intervals."""
    global meeting_state, meeting_thread
    
    print("[Meeting] Heartbeat thread started")
    
    while True:
        try:
            config = load_config()
            
            # Check if Meeting is still enabled
            if config.get('MEETING_ENABLED', 'no') != 'yes':
                print("[Meeting] Meeting disabled, stopping heartbeat thread")
                with meeting_lock:
                    meeting_state['thread_running'] = False
                    meeting_state['connected'] = False
                break
            
            # Check if properly configured
            api_url = config.get('MEETING_API_URL', '')
            device_key = config.get('MEETING_DEVICE_KEY', '')
            
            if not api_url or not device_key:
                print("[Meeting] Not configured, waiting...")
                time.sleep(30)
                continue
            
            # Send heartbeat
            success, error = send_heartbeat_internal(config)
            
            if success:
                print(f"[Meeting] Heartbeat OK at {time.strftime('%H:%M:%S')}")
            else:
                print(f"[Meeting] Heartbeat failed: {error}")
            
            # Wait for next interval
            interval = int(config.get('MEETING_HEARTBEAT_INTERVAL', '60'))
            time.sleep(interval)
            
        except Exception as e:
            print(f"[Meeting] Heartbeat error: {e}")
            time.sleep(30)
    
    print("[Meeting] Heartbeat thread stopped")


def start_heartbeat_thread():
    """Start the heartbeat background thread if not already running."""
    global meeting_thread, meeting_state
    
    with meeting_lock:
        if meeting_state['thread_running']:
            return False  # Already running
        
        config = load_config()
        if config.get('MEETING_ENABLED', 'no') != 'yes':
            return False  # Not enabled
        
        meeting_state['thread_running'] = True
    
    meeting_thread = threading.Thread(target=heartbeat_loop, daemon=True)
    meeting_thread.start()
    return True


def stop_heartbeat_thread():
    """Signal the heartbeat thread to stop (it will stop on next iteration)."""
    global meeting_state
    
    with meeting_lock:
        meeting_state['thread_running'] = False
        meeting_state['connected'] = False


@app.route('/api/meeting/test', methods=['POST'])
def api_meeting_test():
    """Test Meeting API connection and start heartbeat if successful."""
    global meeting_state
    config = load_config()
    
    api_url = config.get('MEETING_API_URL', '').rstrip('/')
    device_key = config.get('MEETING_DEVICE_KEY', '')
    
    if not api_url:
        return jsonify({'success': False, 'message': 'URL de l\'API Meeting non configurée'})
    if not device_key:
        return jsonify({'success': False, 'message': 'Device Key non configurée'})
    
    # Test by checking device availability
    result = meeting_api_request('GET', '/devices/{device_key}/availability', config=config)
    
    if result['success']:
        # Update state and start heartbeat thread
        with meeting_lock:
            meeting_state['last_heartbeat'] = time.time()
            meeting_state['last_heartbeat_error'] = None
            meeting_state['connected'] = True
        
        # Start heartbeat thread if Meeting is enabled
        if config.get('MEETING_ENABLED', 'no') == 'yes':
            start_heartbeat_thread()
        
        return jsonify({
            'success': True, 
            'message': 'Connexion réussie à Meeting API',
            'data': result.get('data')
        })
    else:
        with meeting_lock:
            meeting_state['connected'] = False
            meeting_state['last_heartbeat_error'] = result.get('error', 'Unknown error')
        
        return jsonify({
            'success': False, 
            'message': f'Échec de connexion: {result.get("error", "Unknown error")}',
            'details': result.get('details')
        })


@app.route('/api/meeting/heartbeat', methods=['POST'])
def api_meeting_heartbeat():
    """Send heartbeat to Meeting API (manual trigger)."""
    config = load_config()
    
    payload = build_heartbeat_payload(config)
    success, error = send_heartbeat_internal(config)
    
    if success:
        # Also start the heartbeat thread if not running
        if config.get('MEETING_ENABLED', 'no') == 'yes':
            start_heartbeat_thread()
        
        return jsonify({
            'success': True,
            'message': 'Heartbeat envoyé avec succès',
            'payload': payload
        })
    else:
        return jsonify({
            'success': False,
            'message': f'Échec du heartbeat: {error}'
        })


@app.route('/api/meeting/availability', methods=['GET'])
def api_meeting_availability():
    """Check device availability on Meeting API."""
    result = meeting_api_request('GET', '/devices/{device_key}/availability')
    
    if result['success']:
        return jsonify({
            'success': True,
            'data': result.get('data')
        })
    else:
        return jsonify({
            'success': False,
            'message': result.get('error', 'Unknown error'),
            'details': result.get('details')
        })


@app.route('/api/meeting/device', methods=['GET'])
def api_meeting_device_info():
    """Get device info from Meeting API."""
    config = load_config()
    result = meeting_api_request('GET', '/devices/{device_key}')
    
    if result['success']:
        raw_data = result.get('data', {})
        
        # Also get availability status
        avail_result = meeting_api_request('GET', '/devices/{device_key}/availability')
        is_online = False
        last_heartbeat = None
        if avail_result.get('success') and avail_result.get('data'):
            avail_status = avail_result['data'].get('status', '')
            is_online = avail_status.lower() == 'available'
            last_heartbeat = avail_result['data'].get('last_heartbeat')
        
        # Map to expected fields
        mapped_data = {
            'device_key': raw_data.get('device_key', ''),
            'name': raw_data.get('product_serial', '') or raw_data.get('device_name', ''),
            'online': is_online,
            'ip': raw_data.get('ip_address', ''),
            'last_seen': last_heartbeat,
            'note': raw_data.get('note', ''),
            'services': raw_data.get('services', []),
            'authorized': raw_data.get('authorized', False),
            'token_count': raw_data.get('token_count', 0),
            'ap_ssid': raw_data.get('ap_ssid', ''),
            'ap_password': raw_data.get('ap_password', '')
        }
        
        return jsonify({
            'success': True,
            'data': mapped_data
        })
    else:
        return jsonify({
            'success': False,
            'message': result.get('error', 'Unknown error'),
            'details': result.get('details')
        })


@app.route('/api/meeting/tunnel', methods=['POST'])
def api_meeting_request_tunnel():
    """Request a tunnel from Meeting API."""
    data = request.get_json() or {}
    service = data.get('service', 'ssh')
    
    payload = {'service': service}
    result = meeting_api_request('POST', '/devices/{device_key}/service', data=payload)
    
    if result['success']:
        return jsonify({
            'success': True,
            'message': f'Tunnel {service} demandé',
            'data': result.get('data')
        })
    else:
        return jsonify({
            'success': False,
            'message': result.get('error', 'Unknown error'),
            'details': result.get('details')
        })


@app.route('/api/meeting/status', methods=['GET'])
def api_meeting_status():
    """Get Meeting integration status including heartbeat state."""
    global meeting_state
    config = load_config()
    
    enabled = config.get('MEETING_ENABLED', 'no') == 'yes'
    api_url = config.get('MEETING_API_URL', '')
    device_key = config.get('MEETING_DEVICE_KEY', '')
    provisioned = config.get('MEETING_PROVISIONED', 'no') == 'yes'
    heartbeat_interval = int(config.get('MEETING_HEARTBEAT_INTERVAL', '60'))
    
    with meeting_lock:
        last_heartbeat = meeting_state['last_heartbeat']
        last_error = meeting_state['last_heartbeat_error']
        connected = meeting_state['connected']
        thread_running = meeting_state['thread_running']
    
    # For provisioned devices, check availability from Meeting API directly
    # This ensures we get accurate status even if the heartbeat thread is on another worker
    if provisioned and enabled and api_url and device_key:
        try:
            avail_result = meeting_api_request('GET', '/devices/{device_key}/availability')
            if avail_result.get('success') and avail_result.get('data'):
                avail_status = avail_result['data'].get('status', '')
                connected = avail_status.lower() == 'available'
                last_hb = avail_result['data'].get('last_heartbeat')
                if last_hb:
                    # Parse last_heartbeat from Meeting API (format: "2026-01-16 23:19:38")
                    try:
                        from datetime import datetime
                        dt = datetime.strptime(last_hb, '%Y-%m-%d %H:%M:%S')
                        last_heartbeat = dt.timestamp()
                    except:
                        pass
        except:
            pass  # Keep local state if API call fails
    
    status = {
        'enabled': enabled,
        'configured': bool(api_url and device_key),
        'api_url': api_url,
        'device_key': device_key[:4] + '****' if device_key else '',
        'device_key_full': device_key,  # Full key for provisioned check
        'connected': connected,
        'last_heartbeat': last_heartbeat,
        'last_heartbeat_ago': int(time.time() - last_heartbeat) if last_heartbeat else None,
        'last_error': last_error,
        'heartbeat_thread_running': thread_running,
        'heartbeat_interval': heartbeat_interval,
        'provisioned': provisioned
    }
    
    return jsonify({'success': True, 'status': status})


@app.route('/api/meeting/validate', methods=['POST'])
def api_meeting_validate():
    """Validate Meeting credentials without provisioning - just checks if valid."""
    data = request.get_json() or {}
    api_url = data.get('api_url', '').rstrip('/')
    device_key = data.get('device_key', '').strip().upper()
    token_code = data.get('token_code', '').strip()
    
    if not api_url or not device_key or not token_code:
        return jsonify({
            'success': False,
            'valid': False,
            'message': 'URL API, Device Key et Token Code sont requis'
        })
    
    # Create temporary config for API calls
    temp_config = {
        'MEETING_API_URL': api_url,
        'MEETING_DEVICE_KEY': device_key,
        'MEETING_TOKEN_CODE': token_code
    }
    
    # Get device info to check authorization and token count
    result = meeting_api_request('GET', '/devices/{device_key}', config=temp_config)
    
    if not result['success']:
        return jsonify({
            'success': True,  # Request succeeded, but credentials invalid
            'valid': False,
            'message': f"Impossible de contacter l'API: {result.get('error', 'Unknown error')}"
        })
    
    device_info = result.get('data', {})
    
    # Also get availability status for online info
    avail_result = meeting_api_request('GET', '/devices/{device_key}/availability', config=temp_config)
    is_online = False
    if avail_result.get('success') and avail_result.get('data'):
        avail_status = avail_result['data'].get('status', '')
        is_online = avail_status.lower() == 'available'
    
    return jsonify({
        'success': True,
        'valid': True,
        'device': {
            'name': device_info.get('product_serial', '') or device_info.get('device_name', ''),
            'authorized': device_info.get('authorized', False),
            'token_count': device_info.get('token_count', 0),
            'online': is_online,
            'ip': device_info.get('ip_address', '')
        }
    })


@app.route('/api/meeting/provision', methods=['POST'])
def api_meeting_provision():
    """Provision the device with Meeting API - validates credentials and burns a token."""
    config = load_config()
    
    # Check if already provisioned
    if config.get('MEETING_PROVISIONED', 'no') == 'yes':
        return jsonify({
            'success': False,
            'message': 'Device déjà provisionné. Utilisez le Master Reset pour réinitialiser.',
            'already_provisioned': True
        })
    
    data = request.get_json() or {}
    api_url = data.get('api_url', '').rstrip('/')
    device_key = data.get('device_key', '').strip().upper()
    token_code = data.get('token_code', '').strip()
    
    if not api_url or not device_key or not token_code:
        return jsonify({
            'success': False,
            'message': 'URL API, Device Key et Token Code sont requis'
        })
    
    # Create temporary config for API calls
    temp_config = {
        'MEETING_API_URL': api_url,
        'MEETING_DEVICE_KEY': device_key,
        'MEETING_TOKEN_CODE': token_code
    }
    
    # Step 1: Get device info to check authorization and token count
    result = meeting_api_request('GET', '/devices/{device_key}', config=temp_config)
    
    if not result['success']:
        return jsonify({
            'success': False,
            'message': f"Impossible de contacter l'API Meeting: {result.get('error', 'Unknown error')}",
            'details': result.get('details')
        })
    
    device_info = result.get('data', {})
    
    # Check if device is authorized
    if not device_info.get('authorized'):
        return jsonify({
            'success': False,
            'message': 'Device non autorisé. Contactez l\'administrateur Meeting.',
            'error_type': 'not_authorized'
        })
    
    # Check token count
    token_count = device_info.get('token_count', 0)
    if token_count <= 0:
        return jsonify({
            'success': False,
            'message': 'Aucun token disponible. Contactez l\'administrateur Meeting pour en obtenir.',
            'error_type': 'no_tokens',
            'token_count': token_count
        })
    
    # Step 2: Burn a token via flash-request
    flash_result = meeting_api_request('POST', '/devices/{device_key}/flash-request', config=temp_config)
    
    if not flash_result['success']:
        return jsonify({
            'success': False,
            'message': f"Erreur lors de la consommation du token: {flash_result.get('error', 'Unknown error')}",
            'details': flash_result.get('details')
        })
    
    tokens_left = flash_result.get('data', {}).get('tokens_left', token_count - 1)
    
    # Step 3: Update hostname to device_key
    hostname_result = change_hostname(device_key)
    if not hostname_result['success']:
        # Non-fatal error, continue anyway
        print(f"[Meeting] Warning: Failed to change hostname: {hostname_result.get('message')}")
    
    # Step 4: Save the configuration as provisioned
    config['MEETING_ENABLED'] = 'yes'
    config['MEETING_API_URL'] = api_url
    config['MEETING_DEVICE_KEY'] = device_key
    config['MEETING_TOKEN_CODE'] = token_code
    config['MEETING_PROVISIONED'] = 'yes'
    
    if not save_config(config):
        return jsonify({
            'success': False,
            'message': 'Erreur lors de la sauvegarde de la configuration'
        })
    
    # Start heartbeat thread
    start_heartbeat_thread()
    
    # Schedule a reboot in 5 seconds to apply all changes cleanly
    def delayed_reboot():
        import time
        time.sleep(5)
        try:
            subprocess.run(['sudo', 'reboot'], timeout=10)
        except:
            pass
    
    import threading
    reboot_thread = threading.Thread(target=delayed_reboot, daemon=True)
    reboot_thread.start()
    
    return jsonify({
        'success': True,
        'message': f'Device provisionné avec succès ! Token consommé, {tokens_left} restant(s). Redémarrage dans 5 secondes...',
        'device_key': device_key,
        'tokens_left': tokens_left,
        'hostname_changed': hostname_result.get('success', False),
        'hostname': hostname_result.get('hostname', device_key),
        'rebooting': True
    })


@app.route('/api/meeting/master-reset', methods=['POST'])
def api_meeting_master_reset():
    """Reset Meeting configuration (requires master code)."""
    data = request.get_json() or {}
    master_code = data.get('master_code', '')
    
    # Check master code (for now, hardcoded as "meeting")
    # In production, this should be stored securely
    MASTER_CODE = 'meeting'
    
    if master_code != MASTER_CODE:
        return jsonify({
            'success': False,
            'message': 'Code Master incorrect'
        })
    
    config = load_config()
    
    # Reset Meeting configuration
    config['MEETING_ENABLED'] = 'no'
    config['MEETING_API_URL'] = 'https://meeting.example.com/api'
    config['MEETING_DEVICE_KEY'] = ''
    config['MEETING_TOKEN_CODE'] = ''
    config['MEETING_PROVISIONED'] = 'no'
    
    if not save_config(config):
        return jsonify({
            'success': False,
            'message': 'Erreur lors de la sauvegarde de la configuration'
        })
    
    # Stop heartbeat thread
    stop_heartbeat_thread()
    
    return jsonify({
        'success': True,
        'message': 'Configuration Meeting réinitialisée. Le hostname reste inchangé.'
    })


def change_hostname(new_hostname):
    """Change the system hostname persistently (survives reboot, handles cloud-init)."""
    try:
        # Sanitize hostname (alphanumeric and hyphens only)
        import re
        safe_hostname = re.sub(r'[^a-zA-Z0-9-]', '', new_hostname)
        if not safe_hostname:
            return {'success': False, 'message': 'Hostname invalide après sanitization'}
        
        # Limit length (max 63 chars for hostname)
        safe_hostname = safe_hostname[:63]
        
        # Get old hostname for reference
        old_hostname = get_current_hostname()
        
        # 1. Disable cloud-init hostname management (critical for persistence!)
        cloud_cfg = '/etc/cloud/cloud.cfg'
        try:
            if os.path.exists(cloud_cfg):
                with open(cloud_cfg, 'r') as f:
                    content = f.read()
                
                # Check if preserve_hostname is already set
                if 'preserve_hostname:' in content:
                    # Replace existing setting
                    content = re.sub(r'preserve_hostname:\s*(true|false)', 
                                    'preserve_hostname: true', content)
                else:
                    # Add at the beginning after any comments
                    content = content + '\n# Added by RTSP Recorder provisioning\npreserve_hostname: true\n'
                
                with open('/tmp/cloud.cfg.new', 'w') as f:
                    f.write(content)
                subprocess.run(['sudo', 'cp', '/tmp/cloud.cfg.new', cloud_cfg], check=True, timeout=5)
                print(f"[Meeting] Disabled cloud-init hostname management")
        except Exception as e:
            print(f"[Meeting] Warning: Could not modify cloud-init config: {e}")
        
        # 2. Also disable manage_etc_hosts in cloud-init
        try:
            if os.path.exists(cloud_cfg):
                with open(cloud_cfg, 'r') as f:
                    content = f.read()
                
                if 'manage_etc_hosts:' in content:
                    content = re.sub(r'manage_etc_hosts:\s*(true|false|localhost)', 
                                    'manage_etc_hosts: false', content)
                else:
                    content = content + '\nmanage_etc_hosts: false\n'
                
                with open('/tmp/cloud.cfg.new', 'w') as f:
                    f.write(content)
                subprocess.run(['sudo', 'cp', '/tmp/cloud.cfg.new', cloud_cfg], check=True, timeout=5)
                print(f"[Meeting] Disabled cloud-init /etc/hosts management")
        except Exception as e:
            print(f"[Meeting] Warning: Could not disable manage_etc_hosts: {e}")
        
        # 3. Change hostname using hostnamectl (updates /etc/hostname automatically)
        result = subprocess.run(
            ['sudo', 'hostnamectl', 'set-hostname', safe_hostname],
            capture_output=True, text=True, timeout=10
        )
        
        if result.returncode != 0:
            return {'success': False, 'message': f'hostnamectl error: {result.stderr}'}
        
        # 4. Update /etc/hosts directly
        try:
            with open('/etc/hosts', 'r') as f:
                hosts_content = f.read()
            
            lines = hosts_content.split('\n')
            new_lines = []
            hostname_added = False
            
            # Remove cloud-init comments and rebuild clean hosts file
            for line in lines:
                # Skip cloud-init warning comments
                if line.startswith('#') and ('cloud' in line.lower() or 'manage_etc_hosts' in line.lower()):
                    continue
                # Handle 127.0.1.1 line
                if '127.0.1.1' in line:
                    new_lines.append(f'127.0.1.1\t{safe_hostname}')
                    hostname_added = True
                # Handle 127.0.0.1 line - keep it simple
                elif '127.0.0.1' in line:
                    new_lines.append('127.0.0.1\tlocalhost')
                elif line.strip():  # Keep non-empty lines
                    new_lines.append(line)
            
            # Add 127.0.1.1 entry if not present
            if not hostname_added:
                # Insert after localhost line
                for i, line in enumerate(new_lines):
                    if '127.0.0.1' in line:
                        new_lines.insert(i + 1, f'127.0.1.1\t{safe_hostname}')
                        hostname_added = True
                        break
                if not hostname_added:
                    new_lines.insert(0, f'127.0.1.1\t{safe_hostname}')
            
            with open('/tmp/hosts.new', 'w') as f:
                f.write('\n'.join(new_lines) + '\n')
            
            subprocess.run(['sudo', 'cp', '/tmp/hosts.new', '/etc/hosts'], check=True, timeout=5)
            
        except Exception as e:
            print(f"[Meeting] Warning: Could not update /etc/hosts: {e}")
        
        # 5. Update /etc/hostname directly (belt and suspenders)
        try:
            with open('/tmp/hostname.new', 'w') as f:
                f.write(safe_hostname + '\n')
            subprocess.run(['sudo', 'cp', '/tmp/hostname.new', '/etc/hostname'], check=True, timeout=5)
        except Exception as e:
            print(f"[Meeting] Warning: Could not update /etc/hostname: {e}")
        
        # 6. Restart avahi-daemon to broadcast new hostname via mDNS (.local)
        try:
            subprocess.run(['sudo', 'systemctl', 'restart', 'avahi-daemon'], 
                          capture_output=True, timeout=10)
            print(f"[Meeting] Avahi daemon restarted for mDNS update")
        except Exception as e:
            print(f"[Meeting] Warning: Could not restart avahi-daemon: {e}")
        
        # 7. Set hostname immediately in running system
        try:
            subprocess.run(['sudo', 'hostname', safe_hostname], capture_output=True, timeout=5)
        except Exception as e:
            print(f"[Meeting] Warning: Could not set runtime hostname: {e}")
        
        print(f"[Meeting] Hostname changed from '{old_hostname}' to '{safe_hostname}' (cloud-init disabled)")
        return {'success': True, 'message': f'Hostname changé en {safe_hostname}', 'hostname': safe_hostname}
        
    except subprocess.TimeoutExpired:
        return {'success': False, 'message': 'Timeout lors du changement de hostname'}
    except Exception as e:
        return {'success': False, 'message': str(e)}


def get_current_hostname():
    """Get the current system hostname."""
    try:
        result = subprocess.run(['hostname'], capture_output=True, text=True, timeout=5)
        return result.stdout.strip()
    except:
        return 'unknown'


# ============================================================================
# ONVIF Service Management
# ============================================================================

ONVIF_CONFIG_FILE = '/etc/rpi-cam/onvif.conf'
ONVIF_SERVICE_NAME = 'rpi-cam-onvif'

def load_onvif_config():
    """Load ONVIF configuration from file."""
    default_config = {
        'enabled': False,
        'port': 8080,
        'name': 'RPI-CAM',
        'username': '',
        'password': '',  # Not returned, only has_password indicator
    }
    
    try:
        if os.path.exists(ONVIF_CONFIG_FILE):
            with open(ONVIF_CONFIG_FILE, 'r') as f:
                stored = json.load(f)
                # Merge with defaults
                for key, value in stored.items():
                    if key in default_config:
                        default_config[key] = value
    except Exception as e:
        print(f"[ONVIF] Error loading config: {e}")
    
    return default_config


def save_onvif_config(config):
    """Save ONVIF configuration to file."""
    try:
        # Ensure directory exists
        os.makedirs(os.path.dirname(ONVIF_CONFIG_FILE), exist_ok=True)
        
        with open(ONVIF_CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
        
        # Secure the file (contains password)
        os.chmod(ONVIF_CONFIG_FILE, 0o600)
        
        return True
    except Exception as e:
        print(f"[ONVIF] Error saving config: {e}")
        return False


def sync_onvif_credentials_from_rtsp(main_config):
    """Keep ONVIF WS-Security credentials aligned with RTSP credentials.

    If RTSP_USER and RTSP_PASSWORD are both set, propagate them to onvif.conf
    to avoid mismatched credentials between RTSP and ONVIF. Does not override
    when RTSP credentials are empty.
    """
    try:
        rtsp_user = (main_config.get('RTSP_USER', '') or '').strip()
        rtsp_password = (main_config.get('RTSP_PASSWORD', '') or '').strip()

        if not rtsp_user or not rtsp_password:
            return  # Nothing to sync

        onvif_cfg = load_onvif_config()
        changed = False

        if onvif_cfg.get('username') != rtsp_user:
            onvif_cfg['username'] = rtsp_user
            changed = True
        if onvif_cfg.get('password') != rtsp_password:
            onvif_cfg['password'] = rtsp_password
            changed = True

        if not changed:
            return

        if save_onvif_config(onvif_cfg) and onvif_cfg.get('enabled', False):
            # Restart ONVIF service to apply new credentials (best effort)
            subprocess.run(['sudo', 'systemctl', 'restart', ONVIF_SERVICE_NAME], capture_output=True)
    except Exception as e:
        print(f"[ONVIF] Sync credentials error: {e}")


def is_onvif_service_running():
    """Check if ONVIF service is running."""
    try:
        result = subprocess.run(
            ['systemctl', 'is-active', ONVIF_SERVICE_NAME],
            capture_output=True, text=True
        )
        return result.returncode == 0
    except:
        return False


def get_onvif_device_name_from_meeting():
    """Get ONVIF device name from Meeting API.
    
    Returns the product_serial from Meeting if provisioned,
    otherwise returns 'UNPROVISIONNED'.
    """
    config = load_config()
    api_url = config.get('MEETING_API_URL', '').rstrip('/')
    device_key = config.get('MEETING_DEVICE_KEY', '')
    
    if not api_url or not device_key:
        return 'UNPROVISIONNED', False  # name, is_from_meeting
    
    try:
        result = meeting_api_request('GET', '/devices/{device_key}', config=config)
        if result.get('success') and result.get('data'):
            data = result['data']
            # Try product_serial first, then name, then device_name
            device_name = data.get('product_serial', '') or data.get('name', '') or data.get('device_name', '')
            if device_name:
                return device_name, True
        return 'UNPROVISIONNED', False
    except Exception as e:
        print(f"[ONVIF Status] Error getting device name from Meeting: {e}")
        return 'UNPROVISIONNED', False


@app.route('/api/onvif/status', methods=['GET'])
def api_onvif_status():
    """Get ONVIF service status and configuration."""
    try:
        config = load_onvif_config()
        running = is_onvif_service_running()
        main_config = load_config()
        
        # Get real device name from Meeting API (same logic as onvif_server.py v1.5.0)
        device_name, name_from_meeting = get_onvif_device_name_from_meeting()
        
        # Don't expose password, just indicate if one is set
        safe_config = {
            'port': config.get('port', 8080),
            'name': device_name,
            'name_from_meeting': name_from_meeting,
            'username': config.get('username', ''),
            'has_password': bool(config.get('password', ''))
        }
        
        # Video settings that ONVIF reports
        bitrate_str = main_config.get('H264_BITRATE_KBPS', '') or '0'
        video_settings = {
            'width': int(main_config.get('VIDEO_WIDTH', 640) or 640),
            'height': int(main_config.get('VIDEO_HEIGHT', 480) or 480),
            'fps': int(main_config.get('VIDEO_FPS', 15) or 15),
            'bitrate': int(bitrate_str) if bitrate_str else None
        }
        
        # Get preferred IP (respects interface priority: eth0 > wlan1 > wlan0)
        preferred_ip = get_preferred_ip()
        
        return jsonify({
            'success': True,
            'enabled': config.get('enabled', False),
            'running': running,
            'config': safe_config,
            'video_settings': video_settings,
            'preferred_ip': preferred_ip
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/onvif/config', methods=['GET', 'POST'])
def api_onvif_config():
    """Get or set ONVIF configuration."""
    if request.method == 'GET':
        return api_onvif_status()
    
    try:
        data = request.get_json() or {}
        current_config = load_onvif_config()
        main_config = load_config()
        
        rtsp_user = (main_config.get('RTSP_USER', '') or '').strip()
        rtsp_password = (main_config.get('RTSP_PASSWORD', '') or '').strip()

        username = current_config.get('username', '')
        password = current_config.get('password', '')

        if 'username' in data:
            username = data.get('username', '')
        if 'password' in data and data.get('password'):
            password = data.get('password')

        # If RTSP credentials are set, keep ONVIF credentials shared with RTSP
        if rtsp_user and rtsp_password:
            username = rtsp_user
            password = rtsp_password
        
        # Update configuration
        # Note: 'name' is ignored - it comes from Meeting API (onvif_server.py v1.5.0)
        new_config = {
            'enabled': data.get('enabled', False),
            'port': int(data.get('port', 8080)),
            'username': username,
            'password': password
        }
        
        if not save_onvif_config(new_config):
            return jsonify({'success': False, 'message': 'Erreur sauvegarde configuration'}), 500
        
        # Enable/disable service based on config
        if new_config['enabled']:
            # Start or restart service
            subprocess.run(['sudo', 'systemctl', 'enable', ONVIF_SERVICE_NAME], capture_output=True)
            subprocess.run(['sudo', 'systemctl', 'restart', ONVIF_SERVICE_NAME], capture_output=True)
        else:
            # Stop and disable service
            subprocess.run(['sudo', 'systemctl', 'stop', ONVIF_SERVICE_NAME], capture_output=True)
            subprocess.run(['sudo', 'systemctl', 'disable', ONVIF_SERVICE_NAME], capture_output=True)
        
        return jsonify({'success': True, 'message': 'Configuration ONVIF enregistrée'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/onvif/restart', methods=['POST'])
def api_onvif_restart():
    """Restart ONVIF service."""
    try:
        config = load_onvif_config()
        
        if not config.get('enabled', False):
            return jsonify({'success': False, 'message': 'Service ONVIF non activé'}), 400
        
        result = subprocess.run(
            ['sudo', 'systemctl', 'restart', ONVIF_SERVICE_NAME],
            capture_output=True, text=True
        )
        
        if result.returncode != 0:
            return jsonify({
                'success': False,
                'message': f'Erreur redémarrage: {result.stderr}'
            }), 500
        
        return jsonify({'success': True, 'message': 'Service ONVIF redémarré'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============================================================================
# Application Startup
# ============================================================================

def on_startup():
    """Initialize application on startup."""
    config = load_config()
    
    # Apply camera autofocus setting from config
    video_device = config.get('VIDEO_DEVICE', '/dev/video0')
    if os.path.exists(video_device):
        print(f"[Camera] Applying autofocus setting to {video_device}...")
        apply_camera_autofocus_from_config(video_device)
    
    # Start camera profiles scheduler if enabled
    if config.get('CAMERA_PROFILES_ENABLED', 'no') == 'yes':
        print("[Camera Profiles] Auto-starting scheduler...")
        start_camera_profiles_scheduler()
    
    # Start WiFi failover watchdog if hardware failover is enabled
    wifi_config = load_wifi_failover_config()
    if wifi_config.get('hardware_failover_enabled', True):
        print("[WiFi Failover] Auto-starting watchdog...")
        start_wifi_failover_watchdog()
    
    # Start RTSP watchdog (always enabled for production reliability)
    print("[RTSP Watchdog] Auto-starting for camera monitoring...")
    start_rtsp_watchdog()
    
    # Start heartbeat thread if Meeting is enabled and configured
    if config.get('MEETING_ENABLED', 'no') == 'yes':
        api_url = config.get('MEETING_API_URL', '')
        device_key = config.get('MEETING_DEVICE_KEY', '')
        if api_url and device_key:
            print("[Meeting] Auto-starting heartbeat thread...")
            start_heartbeat_thread()
    
    # WiFi/Ethernet management and Access Point auto-start
    check_auto_ap_on_startup()


def check_auto_ap_on_startup():
    """Check if Access Point should be auto-enabled on startup."""
    config = load_config()
    ap_config = load_ap_config()
    
    # If AP is already explicitly enabled, start it
    if ap_config.get('ap_enabled', False):
        print("[AP] Access Point was enabled, restarting...")
        start_access_point()
        return
    
    # Check if Meeting is configured but no WiFi networks are saved
    meeting_enabled = config.get('MEETING_ENABLED', 'no') == 'yes'
    meeting_device_key = config.get('MEETING_DEVICE_KEY', '')
    
    if meeting_enabled and meeting_device_key:
        # Check if we have any saved WiFi connections
        has_wifi = False
        try:
            result = subprocess.run(['nmcli', '-t', '-f', 'TYPE,NAME', 'connection', 'show'],
                                   capture_output=True, text=True, timeout=10)
            for line in result.stdout.strip().split('\n'):
                if line.startswith('802-11-wireless:'):
                    has_wifi = True
                    break
        except:
            pass
        
        if not has_wifi:
            # No WiFi configured but Meeting is -> enable AP mode
            print("[AP] Meeting configured but no WiFi saved, enabling Access Point mode...")
            
            # Get AP config from Meeting if possible
            try:
                device_info = meeting_api_request('GET', '/devices/{device_key}')
                if device_info.get('success') and device_info.get('data'):
                    data = device_info['data']
                    if data.get('ap_ssid'):
                        ap_config['ap_ssid'] = data['ap_ssid']
                    if data.get('ap_password'):
                        ap_config['ap_password'] = data['ap_password']
                    save_ap_config(ap_config)
            except Exception as e:
                print(f"[AP] Could not fetch Meeting AP config: {e}")
            
            # Start AP if we have SSID and password
            if ap_config.get('ap_ssid') and ap_config.get('ap_password'):
                start_access_point()
            else:
                print("[AP] No AP credentials configured, skipping auto-start")
    
    # Manage WiFi based on Ethernet status (if not in AP mode)
    if not ap_config.get('ap_enabled', False):
        manage_wifi_based_on_ethernet()


# Run startup tasks
on_startup()


if __name__ == '__main__':
    print(f"Platform detected: {PLATFORM['model']}")
    print(f"  - Raspberry Pi: {PLATFORM['is_raspberry_pi']}")
    print(f"  - LED control: {PLATFORM['has_led_control']}")
    print(f"  - GPU control: {PLATFORM['has_vcgencmd']}")
    print(f"  - libcamera: {PLATFORM['has_libcamera']}")
    print(f"  - Boot config: {PLATFORM['boot_config']}")
    app.run(host='0.0.0.0', port=5000, debug=False)
